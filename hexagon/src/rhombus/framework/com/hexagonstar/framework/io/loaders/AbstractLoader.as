/* * rhombus - Application framework for web/desktop-based Flash & Flex projects. *  *  /\ RHOMBUS *  \/ FRAMEWORK *  * Licensed under the MIT License * Copyright (c) 2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.framework.io.loaders{	import com.hexagonstar.event.FileIOEvent;	import com.hexagonstar.framework.util.Log;	import com.hexagonstar.io.file.IFileIOEventListener;	import com.hexagonstar.io.file.QueueFileLoader;	import flash.events.ErrorEvent;	import flash.events.EventDispatcher;	import flash.system.Capabilities;		/**	 * Provides common implementation for concrete loader classes.	 * 	 * @author Sascha Balkau	 * @version 1.0.0	 */	public class AbstractLoader extends EventDispatcher implements IFileIOEventListener	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		protected var _loader:QueueFileLoader;		/** @private */		protected var _preventNotify:Boolean;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new AbstractLoader instance.		 */		public function AbstractLoader()		{			super();		}						/**		 * Starts the load process.		 * Abstract method! Subclasses should override and call super.load()!		 */		public function load():void		{			_preventNotify = false;			_loader = new QueueFileLoader();			_loader.addEventListenersFor(this);		}						/**		 * abort		 */		public function abort():void		{			_loader.abort();		}						/**		 * Disposes the loader.		 */		public function dispose():void		{			_loader.removeEventListenersFor(this);			_loader.dispose();		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Abstract Method.		 */		public function onOpen(e:FileIOEvent):void		{			//Debug.trace(toString() + " Opened: " + e.file.path);		}				/**		 * Abstract Method.		 */		public function onProgress(e:FileIOEvent):void		{			//Debug.trace(toString() + " Load Progress: " + e.file.path);		}				/**		 * Abstract Method.		 */		public function onFileComplete(e:FileIOEvent):void		{			Log.trace(toString() + " Loaded <" + e.file.path + ">.");		}				/**		 * Abstract Method.		 */		public function onComplete(e:FileIOEvent):void		{			//Debug.trace(toString() + " onComplete");		}				/**		 * Abstract Method.		 */		public function onAbort(e:FileIOEvent):void		{			Log.trace(toString() + " Aborted after <" + e.file.path + ">.");		}				/**		 * Abstract Method.		 */		public function onPause(e:FileIOEvent):void		{			Log.trace(toString() + " Paused after <" + e.file.path + ">.");		}				/**		 * Abstract Method.		 */		public function onUnpause(e:FileIOEvent):void		{			Log.trace(toString() + " Unpaused.");		}				/**		 * Abstract Method.		 */		public function onHTTPStatus(e:FileIOEvent):void		{			var code:int = e.httpStatus;			if (code > 0)			{				var status:String = e.httpStatusInfo;				if (code > 399 && code < 600)					Log.warn(toString() + " HTTPStatus: " + status);				else					Log.debug(toString() + " HTTPStatus: " + status);			}		}				/**		 * Abstract Method.		 */		public function onIOError(e:FileIOEvent):void		{			notifyLoadError(e);		}				/**		 * Abstract Method.		 */		public function onSecurityError(e:FileIOEvent):void		{			notifyLoadError(e);		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		protected function notifyLoadError(e:FileIOEvent):void		{			if (!Capabilities.isDebugger)			{				notifyError("Could not load <" + e.file.path + "> (" + e.text + ")");			}			else			{				notifyError(e.text);			}		}						/**		 * Notifies any listener that an error occured during loading/checking the config.		 * @private		 * 		 * @param msg the error message.		 */		protected function notifyError(msg:String):void		{			if (!_preventNotify)			{				_preventNotify = true;								var e:ErrorEvent = new ErrorEvent(ErrorEvent.ERROR);				e.text = toString() + " Error: " + msg;				dispatchEvent(e);			}		}						/**		 * Trims whitespace from the start and end of the specified string.		 * @private		 */		protected static function trim(s:String):String		{			return s.replace(/^[ \t]+|[ \t]+$/g, "");		}	}}