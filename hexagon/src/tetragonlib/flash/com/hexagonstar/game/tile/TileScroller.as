/* * tetragonlib - ActionScript 3 Game Library. *    ____ *   /    / TETRAGON *  /____/  LIBRARY *  * Licensed under the MIT License *  * Copyright (c) 2009 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.game.tile{	import com.hexagonstar.display.Mask;	import com.hexagonstar.display.shapes.RectangleGradientShape;	import com.hexagonstar.game.tile.ds.PropertyMap;	import com.hexagonstar.time.PreciseTimer;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.TimerEvent;	import flash.filters.DropShadowFilter;		/**	 * TileScroller Class	 */	public class TileScroller extends Sprite	{		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////				public static const TILE_ANIM_FPS:int = 12;						////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				public var scrollLeft:Boolean;		public var scrollRight:Boolean;		public var scrollUp:Boolean;		public var scrollDown:Boolean;				protected var _view:Sprite;		protected var _mask:Mask;		protected var _background:Bitmap;		protected var _debugGrid:Sprite;				protected var _tileMap:ITileMap;		protected var _tileSets:PropertyMap;				protected var _scrollSpeed:int = -1;				protected var _xPos:int;		protected var _yPos:int;		protected var _xOld:int;		protected var _yOld:int;				protected var _tileWidth:int;		protected var _tileHeight:int;				/**		 * The width of the visible scroll field.		 * @private		 */		protected var _viewWidth:int;				/**		 * The height of the visible scroll field.		 * @private		 */		protected var _viewHeight:int;				/**		 * The number of tile columns that are visible in the scroller view.		 * @private		 */		protected var _viewCols:int;				/**		 * The number of tile rows that are visible in the scroller view.		 * @private		 */		protected var _viewRows:int;				/**		 * The with of the whole tile map, measured in tiles.		 * @private		 */		protected var _mapWidthTiles:int;				/**		 * The height of the whole tile map, measured in tiles.		 * @private		 */		protected var _mapHeightTiles:int;				/**		 * The with of the whole tile map, measured in pixel.		 * @private		 */		protected var _mapWidthPixel:int;				/**		 * The height of the whole tile map, measured in pixel.		 * @private		 */		protected var _mapHeightPixel:int;				/**		 * Coords that are used to limit the scrolling on the right and bottom		 * of the tile map.		 * @private		 */		protected var scrollBoundaryX:int;		protected var scrollBoundaryY:int;				protected var _layers:Vector.<ITileLayer>;		protected var _layerCount:int;				protected var _timer:PreciseTimer;		protected var _fps:int;		protected var _tick:int;				protected var _isMasked:Boolean = true;		protected var _isPaused:Boolean;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new TileScroller instance.		 * 		 * @param width The width of the scoller area, in pixels.		 * @param height The height of the scoller area, in pixels.		 */		public function TileScroller(width:int = 0, height:int = 0)		{			_viewWidth = width;			_viewHeight = height;						setup();		}						/**		 * addTileSet		 */		public function addTileSet(tileSet:TileSet):void		{			if (_tileSets.size == 0)			{				_tileWidth = tileSet.tileWidth;				_tileHeight = tileSet.tileHeight;			}						_tileSets.put(tileSet.id, tileSet);		}						/**		 * Initializes TileScroller.		 */		public function init():void		{			/* Pause scroller on init. */			_isPaused = true;						scrollLeft = scrollRight = scrollUp = scrollDown = false;			_tick = 0;			_xOld = -1;			_yOld = -1;						if (_scrollSpeed < 0)			{				_scrollSpeed = _tileWidth / 2;			}						_layers = _tileMap.layers;			for each (var l:ITileLayer in _layers)			{				l.masked = _isMasked;			}						_layerCount = _layers.length;						_viewCols = _viewWidth / _tileWidth;			_viewRows = _viewHeight / _tileHeight;						_tileMap.initLayers(_tileSets, _viewWidth, _viewHeight);						_mapWidthPixel = _tileMap.widthPixel;			_mapHeightPixel = _tileMap.heightPixel;						scrollBoundaryX = _mapWidthPixel - _viewWidth - 1;			scrollBoundaryY = _mapHeightPixel - _viewHeight - 1;						setupMask();			setupBackground();			setupLayers();						if (!_isMasked) createDebugGrid();						startTimer();		}						/**		 * start		 */		public function start():void		{			paused = false;		}						/**		 * Pauses the tile scroller.		 */		public function pause():void		{			paused = true;		}						/**		 * Returns a String Representation of TileScroller.		 * 		 * @return A String Representation of TileScroller.		 */		override public function toString():String		{			return "[TileScroller, viewCols=" + _viewCols				+ ", viewRows=" + _viewRows				+ ", mapWidthPixel=" + _mapWidthPixel				+ ", mapHeightPixel=" + _mapHeightPixel + "]";		}						/**		 * Disposes the tile scroller.		 */		public function dispose():void		{		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * The tile map used to display in the tile scroller.		 */		public function get tileMap():ITileMap		{			return _tileMap;		}		public function set tileMap(v:ITileMap):void		{			_tileMap = v;			_mapWidthTiles = _tileMap.widthTiles;			_mapHeightTiles = _tileMap.heightTiles;		}						/**		 * The framerate at that the tile scroller runs. The default value is 30.		 */		public function get fps():int		{			return _fps;		}		public function set fps(fps:int):void		{			_fps = fps;		}						/**		 * The scroll speed of the tile scroller. This value determines by how		 * many pixels the engine scrolls in one tick.		 */		public function get scrollSpeed():int		{			return _scrollSpeed;		}		public function set scrollSpeed(v:int):void		{			_scrollSpeed = v;		}						/**		 * Determines if the tile scroller area is masked or not. Mainly used for		 * debugging.		 */		public function get masked():Boolean		{			return _isMasked;		}		public function set masked(v:Boolean):void		{			_isMasked = v;		}						/**		 * Determines whether the tile scvroller is paused or not.		 */		public function get paused():Boolean		{			return _isPaused;		}		public function set paused(v:Boolean):void		{			_isPaused = v;		}						/**		 * The with of the scroller area, in pixels.		 */		override public function get width():Number		{			return _viewWidth;		}		override public function set width(v:Number):void		{			_viewWidth = v;		}						/**		 * The height of the scroller area, in pixels.		 */		override public function get height():Number		{			return _viewHeight;		}		override public function set height(v:Number):void		{			_viewHeight = v;		}						/**		 * The current x position on the tile map, in pixels.		 */		public function get xPos():int		{			return _xPos;		}		public function set xPos(v:int):void		{			_xPos = v;		}						/**		 * The current y position on the tile map, in pixels.		 */		public function get yPos():int		{			return _yPos;		}		public function set yPos(v:int):void		{			_yPos = v;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		protected function onTimer(e:TimerEvent):void		{			/* Skip whole loop code if we are paused. */			if (_isPaused) return;						/* Check for left/right scrolling */			if (scrollRight)			{				_xPos += _scrollSpeed;			}			else if (scrollLeft)			{				_xPos -= _scrollSpeed;			}						/* Check for up/down scrolling */			if (scrollDown)			{				_yPos += _scrollSpeed;			}			else if (scrollUp)			{				_yPos -= _scrollSpeed;			}						/* Limit x position to map dimensions */			if (_xPos < 0)			{				_xPos = 0;			}			else if (_xPos > scrollBoundaryX)			{				_xPos = scrollBoundaryX;			}						/* Limit y position to map dimensions */			if (_yPos < 0)			{				_yPos = 0;			}			else if (_yPos > scrollBoundaryY)			{				_yPos = scrollBoundaryY;			}						/* No need to update rendering if there is no scrolling */			if (_xPos == _xOld && _yPos == _yOld)			{				//return;			}						drawLayers();						_xOld = _xPos;			_yOld = _yPos;		}				////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * setup		 * @private		 */		protected function setup():void		{			_fps = 30;			_xPos = 0;			_yPos = 0;						_tileSets = new PropertyMap(10);						_view = new Sprite();			addChild(_view);		}						/**		 * Creates the timer or if the timer already exists, updates it with		 * the current delay value.		 * @private		 */		protected function setupTimer():void		{			var ms:int = Math.round(1000 / _fps);						if (!_timer)			{				_timer = new PreciseTimer(ms, 0);				_timer.addEventListener(TimerEvent.TIMER, onTimer);			}			else			{				_timer.delay = ms;			}		}						/**		 * Starts the timer to run the scroll loop.		 * @private		 */		protected function startTimer():void		{			if (!_timer)			{				setupTimer();			}			_timer.start();		}						/**		 * Sets up the mask of the tile scroller. If a mask already exists and masked is		 * then set to false and then this method is called, it only removes the existing		 * mask.		 * @private		 */		protected function setupMask():void		{			if (_mask)			{				_view.mask = null;				removeChild(_mask);				_mask = null;			}						if (_isMasked)			{				_mask = new Mask(_viewWidth, _viewHeight);				_view.mask = _mask;				addChild(_mask);			}		}				/**		 * setupBackground		 * @private		 */		protected function setupBackground():void		{			if (_background)			{				_view.removeChild(_background);				_background = null;			}						var bgColor:uint = _tileMap.backgroundColor;			var bgGradient:String = _tileMap.properties.getValue("backgroundGradient");			var bmd:BitmapData = new BitmapData(_viewWidth, _viewHeight, false, bgColor);						if (bgGradient)			{				var a:Array = PropertyMap.parseArrayProperty(bgGradient);				if (a)				{					bmd.draw(generateGradientShape(a));				}			}						_background = new Bitmap(bmd);			_view.addChild(_background);		}						/**		 * setupLayers		 * @private		 */		protected function setupLayers():void		{			for (var i:int = 0; i < _layerCount; i++)			{				var layer:ITileLayer = _layers[i];				addLayerFilters(layer);				//layer.draw(_xPos, _yPos);				_view.addChild(layer as DisplayObject);			}		}						/**		 * drawLayers		 * @private		 */		protected function drawLayers():void		{			for (var i:int = 0; i < _layerCount; i++)			{				var layer:ITileLayer = _layers[i];				layer.draw(_xPos, _yPos);			}		}				/**		 * Generates a GradientShape from the specified array. The array's first		 * value is used as the gradient's rotation (in degrees) and every following		 * value is used as a color, e.g. [-90, 0xFF2233, 0x4400FF, 0x00FFFF, ...].		 * The array can have an arbitrary amount of color values.		 * @private		 * 		 * @param a The array with gradient values.		 * @return A RectangleGradientShape.		 */		protected function generateGradientShape(a:Array):RectangleGradientShape		{			var r:Number = a.shift();			var l:int = a.length;			var f:Number = (255 / (l - 1));			var ratio:Number = 0;			var ratios:Array = [];			var alphas:Array = [];						for (var i:int = 0; i < l; i++)			{				ratios.push(Math.floor(ratio));				alphas.push(1.0);				ratio += f;			}						var shape:RectangleGradientShape = new RectangleGradientShape();			shape.draw(_viewWidth, _viewHeight, r, a, alphas, ratios);			return shape;		}						/**		 * Adds filters to the specified layer.		 * @private		 */		protected function addLayerFilters(layer:ITileLayer):void		{			var filters:Array = [];						var dropShadow:String = layer.properties.getValue("dropShadow");			if (dropShadow)			{				var a:Array = PropertyMap.parseArrayProperty(dropShadow);				var dst:Number = a[0];				var ang:Number = a[1];				var col:uint = a[2];				var alp:Number = a[3];				var blX:Number = a[4];				var blY:Number = a[5];				var str:Number = a[6];				var qal:int = a[7];				var inr:Boolean = (a[8] == "true" ? true : false);				filters.push(new DropShadowFilter(dst, ang, col, alp, blX, blY, str, qal, inr));			}						if (filters.length > 0)			{				layer.filters = filters;			}		}						/**		 * createDebugGrid		 * @private		 */		protected function createDebugGrid():void		{			_debugGrid = new Sprite();			var color:uint = 0xFF0000;						for (var y:int = 0; y <= _viewRows; y++)			{				for (var x:int = 0; x <= _viewCols; x++)				{					if (y == 0 || y == _viewRows || x == 0 || x == _viewCols)					{						_debugGrid.graphics.lineStyle(1, color, 0.4);					}					else					{						_debugGrid.graphics.lineStyle(1, color, 1.0);					}										_debugGrid.graphics.drawRect(x * _tileWidth, y * _tileHeight,						_tileWidth, _tileHeight);				}			}						if (_mask) _debugGrid.mask = _mask;			addChild(_debugGrid);		}	}}