/* * tetragonlib - ActionScript 3 Game Library. *    ____ *   /    / TETRAGON *  /____/  LIBRARY *  * Licensed under the MIT License *  * Copyright (c) 2009 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.game.tile{	import com.hexagonstar.display.Mask;	import com.hexagonstar.display.shapes.RectangleGradientShape;	import com.hexagonstar.game.tile.ds.PropertyMap;	import com.hexagonstar.time.PreciseTimer;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.TimerEvent;	import flash.filters.DropShadowFilter;		/**	 * TileScroller Class	 */	public class TileScroller extends Sprite	{		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////				public static const TILE_ANIM_FPS:int = 12;						////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _window:Sprite;		protected var _mask:Mask;		protected var _background:BitmapData;				protected var _windowWidth:int;		protected var _windowHeight:int;				protected var _tileMap:ITileMap;		protected var _tileSets:PropertyMap;				protected var _mapWidth:int;		protected var _mapHeight:int;				protected var _layers:Vector.<ITileLayer>;		protected var _layerCount:int;				protected var _timer:PreciseTimer;		protected var _fps:int;		protected var _tick:int;				protected var _isMasked:Boolean = true;		protected var _isPaused:Boolean = false;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new TileScroller instance.		 * 		 * @param width The width of the scoller area, in pixels.		 * @param height The height of the scoller area, in pixels.		 */		public function TileScroller(width:int = 0, height:int = 0)		{			_windowWidth = width;			_windowHeight = height;						setup();		}						/**		 * addTileSet		 */		public function addTileSet(tileSet:TileSet):void		{			_tileSets.put(tileSet.id, tileSet);		}						/**		 * Initializes TileScroller.		 */		public function init():void		{			_tick = 0;						_layers = _tileMap.layers;			_layerCount = _layers.length;						_tileMap.initLayers(_tileSets, _windowWidth, _windowHeight);						var ms:int = Math.round(1000 / _fps);			_timer = new PreciseTimer(ms, 0);			_timer.addEventListener(TimerEvent.TIMER, onTimer);		}				/**		 * start		 */		public function start():void		{			addMask();			addBackground();			addLayers();			//draw();						_timer.start();		}						/**		 * stop		 */		public function stop():void		{		}						/**		 * Disposes TileScroller.		 */		public function dispose():void		{		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				public function get tileMap():ITileMap		{			return _tileMap;		}		public function set tileMap(v:ITileMap):void		{			_tileMap = v;			_mapWidth = _tileMap.width;			_mapHeight = _tileMap.height;		}						public function get fps():int		{			return _fps;		}		public function set fps(fps:int):void		{			_fps = fps;		}						public function get masked():Boolean		{			return _isMasked;		}		public function set masked(v:Boolean):void		{			_isMasked = v;		}						public function get paused():Boolean		{			return _isPaused;		}		public function set paused(v:Boolean):void		{			_isPaused = v;		}						override public function get width():Number		{			return _windowWidth;		}		override public function set width(v:Number):void		{			_windowWidth = v;		}						override public function get height():Number		{			return _windowHeight;		}		override public function set height(v:Number):void		{			_windowHeight = v;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		protected function onTimer(e:TimerEvent):void		{			//draw();		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * setup		 * @private		 */		protected function setup():void		{			_fps = 30;			_tileSets = new PropertyMap(10);			_window = new Sprite();			addChild(_window);					}						/**		 * addMask		 * @private		 */		protected function addMask():void		{			if (_isMasked)			{				_mask = new Mask(_windowWidth, _windowHeight);				_window.mask = _mask;				addChild(_mask);			}		}				/**		 * addBackground		 * @private		 */		protected function addBackground():void		{			var bgColor:uint = _tileMap.backgroundColor;			_background = new BitmapData(_windowWidth, _windowHeight, false, bgColor);						var bgGradient:String = _tileMap.properties.getValue("backgroundGradient");			if (bgGradient)			{				var a:Array = PropertyMap.parseArrayProperty(bgGradient);				if (a) _background.draw(generateGradientShape(a));			}						_window.addChild(new Bitmap(_background));		}						/**		 * addLayers		 * @private		 */		protected function addLayers():void		{			for (var i:int = 0;i < _layerCount; i++)			{				var layer:ITileLayer = _layers[i];				addLayerFilters(layer);				layer.draw();				_window.addChild(layer as DisplayObject);			}		}						/**		 * draw		 * @private		 */		protected function draw():void		{		}						/**		 * Generates a GradientShape from the specified array. The array's first		 * value is used as the gradient's rotation (in degrees) and every following		 * value is used as a color, e.g. [-90, 0xFF2233, 0x4400FF, 0x00FFFF, ...].		 * The array can have an arbitrary amount of color values.		 * @private		 * 		 * @param a The array with gradient values.		 * @return A RectangleGradientShape.		 */		protected function generateGradientShape(a:Array):RectangleGradientShape		{			var r:Number = a.shift();			var l:int = a.length;			var f:Number = (255 / (l - 1));			var ratio:Number = 0;			var ratios:Array = [];			var alphas:Array = [];						for (var i:int = 0; i < l; i++)			{				ratios.push(Math.floor(ratio));				alphas.push(1.0);				ratio += f;			}						var shape:RectangleGradientShape = new RectangleGradientShape();			shape.draw(_windowWidth, _windowHeight, r, a, alphas, ratios);			return shape;		}						/**		 * Adds filters to the specified layer.		 * @private		 */		protected function addLayerFilters(layer:ITileLayer):void		{			var filters:Array = [];						var dropShadow:String = layer.properties.getValue("dropShadow");			if (dropShadow)			{				var a:Array = PropertyMap.parseArrayProperty(dropShadow);				var dst:Number = a[0];				var ang:Number = a[1];				var col:uint = a[2];				var alp:Number = a[3];				var blX:Number = a[4];				var blY:Number = a[5];				var str:Number = a[6];				var qal:int = a[7];				var inr:Boolean = (a[8] == "true" ? true : false);				filters.push(new DropShadowFilter(dst, ang, col, alp, blX, blY, str, qal, inr));			}						if (filters.length > 0)			{				layer.filters = filters;			}		}						/**		 * drawLayerToBuffer		 * @private		 *///		protected function drawLayerToBuffer(layer:TileLayer):void//		{//			var grid:Grid2D = layer.grid;//			var tile:ITile;//			var tileID:int;//			var xPos:int;//			var yPos:int;//			//			_rectangle = new Rectangle(0, 0, _tileWidth, _tileHeight);//			//			for (var y:int = 0; y < _mapHeight; y++)//			{//				for (var x:int = 0; x < _mapWidth; x++)//				{//					tileID = grid.getCell(x, y);//					//					/* Only draw tiles if necessary *///					if (tileID > 0)//					{//						tile = _tileSet.getTile(tileID);//						_point.x = x * _tileWidth;//						_point.y = y * _tileHeight;//						//						if (tile is AnimTile)//						{//							tile = _tileSet.duplicateTile(tile);//							tile.x = _point.x;//							tile.y = _point.y;//							layer.addChild(tile as DisplayObject);//							_buffer.draw(layer);//						}//						else//						{//							_buffer.copyPixels((tile as Tile).bitmapData, _rectangle, _point);//						}//					}//				}//			}//		}						/**		 * fillBuffer - only for testing!		 * @private		 *///		private function fillBuffer():void//		{//			var tileCount:int = _tileSet.tileCount;//			var tilesH:int = Math.ceil(_buffer.width / _tileWidth);//			var tilesV:int = Math.ceil(_buffer.height / _tileHeight);//			//			_rectangle = new Rectangle(0, 0, _tileWidth, _tileHeight);//			//			for (var y:int = 0; y < tilesV; y++)//			{//				for (var x:int = 0; x < tilesH; x++)//				{//					var rnd:int = (Math.random() * tileCount) + 1;//					var tile:Tile = _tileSet.getTile(rnd) as Tile;//					//					_point.x = x * _tileWidth;//					_point.y = y * _tileHeight;//					//					if (tile is AnimTile)//					{//						tile = _tileSet.duplicateTile(tile) as Tile;//						tile.x = _point.x;//						tile.y = _point.y;//						//					}//					else//					{//						_buffer.copyPixels(tile.bitmapData, _rectangle, _point);//					}//				}//			}//			//			addChild(new Bitmap(_buffer));//			//_window.draw(_buffer);//		}	}}