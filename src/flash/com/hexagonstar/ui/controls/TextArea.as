/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.ui.controls{	import com.hexagonstar.ui.core.InvalidationType;	import com.hexagonstar.ui.core.UIComponent;	import com.hexagonstar.ui.events.ComponentEvent;	import com.hexagonstar.ui.events.ScrollEvent;	import com.hexagonstar.ui.managers.IFocusManager;	import com.hexagonstar.ui.managers.IFocusManagerComponent;		import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.FocusEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.events.TextEvent;	import flash.system.IME;	import flash.text.TextField;	import flash.text.TextFieldType;	import flash.text.TextFormat;	import flash.text.TextLineMetrics;	import flash.ui.Keyboard;			[Event(name="change", type="flash.events.Event")]	[Event(name="textInput", type="flash.events.TextEvent")]	[Event(name="enter", type="com.hexagonstar.env.event.ComponentEvent")]	[Event(name="scroll", type="com.hexagonstar.env.event.ScrollEvent")]		[Style(name="upSkin", type="Class")]	[Style(name="disabledSkin", type="Class")]	[Style(name="textPadding", type="Number", format="Length")]	[Style(name="embedFonts", type="Boolean")]			/**	 * The TextArea component is a multiline text field with a border and optional	 * scroll bars. The TextArea component supports the HTML rendering capabilities	 * of Adobe Flash Player.	 * 	 * TODO Should return correct width/height when scrollbar is displayed and should	 * draw focus rectangle around textfield and scrollbar!	 *	 * @see TextInput	 */	public class TextArea extends UIComponent implements IFocusManagerComponent	{		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////				protected static const SCROLL_BAR_STYLES:Object =		{			downArrowDisabledSkin: "downArrowDisabledSkin",			downArrowDownSkin: "downArrowDownSkin",			downArrowOverSkin: "downArrowOverSkin",			downArrowUpSkin: "downArrowUpSkin",			upArrowDisabledSkin: "upArrowDisabledSkin",			upArrowDownSkin: "upArrowDownSkin",			upArrowOverSkin: "upArrowOverSkin",			upArrowUpSkin: "upArrowUpSkin",			thumbDisabledSkin: "thumbDisabledSkin",			thumbDownSkin: "thumbDownSkin",			thumbOverSkin: "thumbOverSkin",			thumbUpSkin: "thumbUpSkin",			thumbIcon: "thumbIcon",			trackDisabledSkin: "trackDisabledSkin",			trackDownSkin: "trackDownSkin",			trackOverSkin: "trackOverSkin",			trackUpSkin: "trackUpSkin",			repeatDelay: "repeatDelay",			repeatInterval: "repeatInterval"		};						////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _tf:TextField;		protected var _bg:DisplayObject;		protected var _hScrollPolicy:String = ScrollPolicy.AUTO;		protected var _vScrollPolicy:String = ScrollPolicy.AUTO;		protected var _hScrollBar:UIScrollBar;		protected var _vScrollBar:UIScrollBar;				protected var _savedHTML:String;				protected var _isWordWrap:Boolean = true;		protected var _isEditable:Boolean = true;		protected var _isHTML:Boolean = false;		protected var _isTextChanged:Boolean = false;				private static var _defaultStyles:Object =		{			upSkin:				"TextInputUp",			disabledSkin:		"TextInputDisabled",			focusRectSkin:		null,			focusRectPadding:	null,			textFormat:			null,			disabledTextFormat:	null,			textPadding:		3,			embedFonts:			false		};						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new TextArea instance.		 */		public function TextArea()		{			super();		}						/**		 * @copy com.hexagonstar.ui.core.UIComponent#drawFocus()		 */		override public function drawFocus(draw:Boolean):void		{			if (focusTarget)			{				focusTarget.drawFocus(draw);				return;			}			super.drawFocus(draw);		}						/**		 * Retrieves information about a specified line of text.		 * @param lineIndex The line number for which information is to be retrieved.		 */		public function getLineMetrics(lineIndex:int):TextLineMetrics		{			return _tf.getLineMetrics(lineIndex);		}						/**		 * Sets the range of a selection made in a text area that has focus.		 * The selection range begins at the index that is specified by the start 		 * parameter, and ends at the index that is specified by the end parameter.		 * The selected text is treated as a zero-based string of characters in which		 * the first selected character is located at index 0, the second 		 * character at index 1, and so on.		 * <p>This method has no effect if the text field does not have focus.</p>		 *		 * @param setSelection The index location of the first character in the selection.		 * @param endIndex The index position of the last character in the selection.		 */		public function setSelection(beginIndex:int, endIndex:int):void		{			_tf.setSelection(beginIndex, endIndex);		}						/**		 * Appends the specified string after the last character that the TextArea 		 * component contains. This method is more efficient than concatenating two		 * strings by using an addition assignment on a text property--for example, 		 * <code>myTextArea.text += moreText</code>. This method is particularly		 * useful when the TextArea component contains a significant amount of		 * content. 		 * 		 * @param text The string to be appended to the existing text.		 */		public function appendText(text:String):void		{			_tf.appendText(text);			invalidate(InvalidationType.DATA);		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @copy com.hexagonstar.ui.core.UIComponent#getStyleDefinition()		 *		 * @see com.hexagonstar.ui.core.UIComponent#getStyle() UIComponent#getStyle()		 * @see com.hexagonstar.ui.core.UIComponent#setStyle() UIComponent#setStyle()		 * @see com.hexagonstar.ui.managers.StyleManager StyleManager		 */		public static function get styleDefinition():Object		{			return UIComponent.mergeStyles(_defaultStyles, ScrollBar.styleDefinition);		}						/**		 * Gets a reference to the horizontal scroll bar.		 * @see #verticalScrollBar		 */		public function get horizontalScrollBar():UIScrollBar		{ 			return _hScrollBar;		}				/**		 * Gets a reference to the vertical scroll bar.		 * @see #horizontalScrollBar		 */		public function get verticalScrollBar():UIScrollBar		{			return _vScrollBar;		}						/**		 * @copy com.hexagonstar.ui.core.UIComponent#enabled		 */		override public function get enabled():Boolean		{			return super.enabled;		}				override public function set enabled(v:Boolean):void		{			super.enabled = v;			/* Disables mouseWheel interaction. */			mouseChildren = enabled;			invalidate(InvalidationType.STATE);		}						/**		 * Gets or sets a string which contains the text that is currently in 		 * the TextInput component. This property contains text that is unformatted 		 * and does not have HTML tags. To retrieve this text formatted as HTML, use 		 * the <code>htmlText</code> property.		 * 		 * @see #htmlText		 */		public function get text():String		{			return _tf.text;		}				public function set text(v:String):void		{			_tf.text = v;			_isHTML = false;			invalidate(InvalidationType.DATA);			invalidate(InvalidationType.STYLES);			_isTextChanged = true;		}						/**		 * Gets or sets the HTML representation of the string that the text field contains.		 * @see #text		 * @see flash.text.TextField#htmlText TextField.htmlText		 */		public function get htmlText():String		{			return _tf.htmlText;		}				public function set htmlText(v:String):void		{			if (v == "")			{				text = "";				return;			}			_isHTML = true;			_savedHTML = v;			_tf.htmlText = v;			invalidate(InvalidationType.DATA);			invalidate(InvalidationType.STYLES);			_isTextChanged = true;		}						/**		 * Gets or sets a Boolean value that indicates whether extra white space		 * is removed from a TextArea component that contains HTML text. Examples 		 * of extra white space in the component include spaces and line breaks. 		 * A value of <code>true</code> indicates that extra white space is removed; 		 * a value of <code>false</code> indicates that extra white space is not removed.		 *		 * <p>This property affects only text that is set by using the <code>htmlText		 * </code> property; it does not affect text that is set by using the <code>text		 * </code> property. If you use the <code>text</code> property to set text, the		 * <code>condenseWhite</code> property is ignored.</p>		 *		 * <p>If the <code>condenseWhite</code> property is set to <code>true</code>, you 		 * must use standard HTML commands, such as &lt;br&gt; and &lt;p&gt;, to place line 		 * breaks in the text field.</p>		 * 		 * @see flash.text.TextField#condenseWhite TextField.condenseWhite		 */		public function get condenseWhite():Boolean		{			return _tf.condenseWhite;		}				public function set condenseWhite(v:Boolean):void		{			_tf.condenseWhite = v;			invalidate(InvalidationType.DATA);		}						/**		 * Gets or sets the scroll policy for the horizontal scroll bar. 		 * This can be one of the following values:		 * <ul>		 * <li>ScrollPolicy.ON: The horizontal scroll bar is always on.</li>		 * <li>ScrollPolicy.OFF: The scroll bar is always off.</li>		 * <li>ScrollPolicy.AUTO: The scroll bar turns on when it is needed.</li>		 * </ul>		 * 		 * @see #verticalScrollPolicy		 * @see ScrollPolicy		 */		public function get horizontalScrollPolicy():String		{			return _hScrollPolicy;		}				public function set horizontalScrollPolicy(v:String):void		{			_hScrollPolicy = v;			invalidate(InvalidationType.SIZE);		}						/**		 * Gets or sets the scroll policy for the vertical scroll bar. 		 * This can be one of the following values:		 * <ul>		 * <li>ScrollPolicy.ON: The scroll bar is always on.</li>		 * <li>ScrollPolicy.OFF: The scroll bar is always off.</li>		 * <li>ScrollPolicy.AUTO: The scroll bar turns on when it is needed.</li>		 * </ul>		 * 		 * @see #horizontalScrollPolicy		 * @see ScrollPolicy		 */		public function get verticalScrollPolicy():String		{			return _vScrollPolicy;		}				public function set verticalScrollPolicy(v:String):void		{			_vScrollPolicy = v;			invalidate(InvalidationType.SIZE);		}						/**		 * Gets or sets the change in the position of the scroll bar thumb, in pixels,		 * after the user scrolls the text field horizontally. If this value is 0, the		 * text field was not horizontally scrolled.		 * 		 * @see #verticalScrollPosition		 */		public function get horizontalScrollPosition():Number		{			return _tf.scrollH;		}				public function set horizontalScrollPosition(value:Number):void 		{			/* We must force a redraw to ensure that the size is up to date. */			drawNow();			_tf.scrollH = value;		}						/**		 * Gets or sets the change in the position of the scroll bar thumb, in  pixels,		 * after the user scrolls the text field vertically. If this value is 1, the text		 * field was not vertically scrolled.		 * 		 * @see #horizontalScrollPosition		 */		public function get verticalScrollPosition():Number		{			return _tf.scrollV;		}				public function set verticalScrollPosition(v:Number):void		{			/* We must force a redraw to ensure that the size is up to date. */			drawNow();			_tf.scrollV = v;		}						/**		 * Gets the width of the text, in pixels.		 * @see #textHeight		 */		public function get textWidth():Number		{			drawNow();			return _tf.textWidth;		}						/**		 * Gets the height of the text, in pixels.		 * @see #textWidth		 */		public function get textHeight():Number		{			drawNow();			return _tf.textHeight;		}						/**		 * Gets the count of characters that the TextArea component contains.		 * @see #maxChars		 */		public function get length():Number		{			return _tf.text.length;		}						/**		 * Gets or sets the string of characters that the text field  		 * accepts from a user. 		 *		 * <p>Note that characters that are not included in this string 		 * are accepted in the text field if they are entered programmatically.</p>		 *		 * <p>The characters in the string are read from left to right. You can 		 * specify a character range by using the hyphen (-) character. </p>		 *		 * <p>If the value of this property is <code>null</code>, the text field 		 * accepts all characters. If this property is set to an empty string (""), 		 * the text field accepts no characters. </p>		 *		 * <p>If the string begins with a caret (^) character, all characters 		 * are initially accepted and succeeding characters in the string 		 * are excluded from the set of accepted characters. If the string 		 * does not begin with a caret (^) character, no characters are 		 * initially accepted and succeeding characters in the string are 		 * included in the set of accepted characters.</p>		 * 		 * @see flash.text.TextField#restrict TextField.restrict		 */		public function get restrict():String		{			return _tf.restrict;		}				public function set restrict(v:String):void		{			_tf.restrict = v;		}						/**		 * Gets or sets the maximum number of characters that a user can enter		 * in the text field.		 * @see #length		 */		public function get maxChars():int		{			return _tf.maxChars;		}				public function set maxChars(v:int):void		{			_tf.maxChars = v;		}						/**		 * Gets the maximum value of the <code>horizontalScrollPosition</code> property.		 * @see #horizontalScrollPosition		 * @see #maxVScrollPosition		 */		public function get maxHScrollPosition():int		{			return _tf.maxScrollH;		}						/**		 * Gets the maximum value of the <code>verticalScrollPosition</code> property.		 * @see #verticalScrollPosition		 * @see #maxHScrollPosition		 */		public function get maxVScrollPosition():int		{			return _tf.maxScrollV;		}						/**		 * Gets or sets a Boolean value that indicates whether the text		 * wraps at the end of the line. A value of <code>true</code> 		 * indicates that the text wraps; a value of <code>false</code>		 * indicates that the text does not wrap. 		 *		 * @see flash.text.TextField#wordWrap TextField.wordWrap		 */				public function get wordWrap():Boolean		{			return _isWordWrap;		}				public function set wordWrap(v:Boolean):void		{			_isWordWrap = v;			invalidate(InvalidationType.STATE);		}						/**		 * Gets the index position of the first selected character in a selection of		 * one or more characters. 		 *		 * <p>The index position of a selected character is zero-based and calculated		 * from the first character that appears in the text area. If there is no		 * selection, this value is set to the position of the caret.</p>		 * 		 * @see #selectionEndIndex		 * 		 */		public function get selectionBeginIndex():int		{			return _tf.selectionBeginIndex;		}						/**		 * Gets the index position of the last selected character in a selection of		 * one or more characters. 		 *		 * <p>The index position of a selected character is zero-based and calculated		 * from the first character that appears in the text area. If there is no		 * selection, this value is set to the position of the caret.</p>		 *		 * @see #selectionBeginIndex		 */		public function get selectionEndIndex():int		{			return _tf.selectionEndIndex;		}						/**		 * Gets or sets a Boolean value that indicates whether the TextArea component 		 * instance is the text field for a password. A value of <code>true</code>		 * indicates that the current instance was created to contain a password;		 * a value of <code>false</code> indicates that it was not. 		 *		 * <p>If the value of this property is <code>true</code>, the characters 		 * that the user enters in the text area cannot be seen. Instead,		 * an asterisk is displayed in place of each character that the		 * user enters. Additionally, the Cut and Copy commands and their keyboard		 * shortcuts are disabled to prevent the recovery of a password from		 * an unattended computer.</p>		 */				public function get displayAsPassword():Boolean		{			return _tf.displayAsPassword;		}				public function set displayAsPassword(v:Boolean):void		{			_tf.displayAsPassword = v;		}						/**		 * Gets or sets a Boolean value that indicates whether the user can		 * edit the text in the component. A value of <code>true</code> indicates		 * that the user can edit the text that the component contains; a value of		 * <code>false</code> indicates that it cannot. 		 */				public function get editable():Boolean		{			return _isEditable;		}				public function set editable(v:Boolean):void		{			_isEditable = v;			invalidate(InvalidationType.STATE);		}						/**		 * Gets or sets the mode of the input method editor (IME). The IME makes		 * it possible for users to use a QWERTY keyboard to enter characters from 		 * the Chinese, Japanese, and Korean character sets.		 *		 * <p>Flash sets the IME to the specified mode when the component gets focus, 		 * and restores it to the original value after the component loses focus. </p>		 *		 * <p>The flash.system.IMEConversionMode class defines constants for 		 * the valid values for this property. Set this property to <code>null</code> to 		 * prevent the use of the IME with the component.</p>		 * 		 * @see flash.system.IMEConversionMode		 */		public function get imeMode():String		{			return IME.conversionMode;		}				public function set imeMode(v:String):void		{			_imeMode = v;		}						/**		 * Gets or sets a Boolean value that indicates whether Flash Player		 * highlights a selection in the text field when the text field 		 * does not have focus.		 *		 * If this value is set to <code>true</code> and the text field does not		 * have focus, Flash Player highlights the selection in gray. If this value 		 * is set to <code>false</code> and the text field does not have focus, Flash 		 * Player does not highlight the selection.  		 *		 * @see flash.text.TextField#alwaysShowSelection TextField.alwaysShowSelection		 */		public function get alwaysShowSelection():Boolean		{			return _tf.alwaysShowSelection;		}				public function set alwaysShowSelection(v:Boolean):void		{			_tf.alwaysShowSelection = v;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		override protected function onFocusIn(e:FocusEvent):void		{			setIMEMode(true);						if (e.target == this) stage.focus = _tf;			var fm:IFocusManager = focusManager;						if (fm)			{				if (editable) fm.showFocusIndicator = true;				fm.defaultButtonEnabled = false;			}						super.onFocusIn(e);			if (editable) setIMEMode(true);		}				/**		 * @private		 */		override protected function onFocusOut(e:FocusEvent):void		{			var fm:IFocusManager = focusManager;			if (fm) fm.defaultButtonEnabled = true;			setSelection(0, 0);			super.onFocusOut(e);			if (editable) setIMEMode(false);		}						/**		 * @private		 */		protected function onKeyDown(e:KeyboardEvent):void		{			if (e.keyCode == Keyboard.ENTER)				dispatchEvent(new ComponentEvent(ComponentEvent.ENTER, true));		}						/**		 * @private		 */		protected function onChange(e:Event):void		{			/* so you don't get two change events */			e.stopPropagation();			dispatchEvent(new Event(Event.CHANGE, true));			invalidate(InvalidationType.DATA);		}						/**		 * @private		 */		protected function onTextInput(e:TextEvent):void		{			e.stopPropagation();			dispatchEvent(new TextEvent(TextEvent.TEXT_INPUT, true, false, e.text));		}						/**		 * @private		 */		protected function onScroll(e:ScrollEvent):void		{			dispatchEvent(e);		}						/**		 * @private		 */		protected function onMouseWheel(e:MouseEvent):void		{			if (!enabled || !_vScrollBar.visible) return;			_vScrollBar.scrollPosition -= e.delta * _vScrollBar.lineScrollSize;			dispatchEvent(new ScrollEvent(ScrollBarDirection.VERTICAL,				e.delta * _vScrollBar.lineScrollSize, _vScrollBar.scrollPosition));		}						/**		 * @private		 */		protected function onDelayedLayoutUpdate(e:Event):void		{			if (_isTextChanged)			{				_isTextChanged = false;				drawLayout();				return;			}			removeEventListener(Event.ENTER_FRAME, onDelayedLayoutUpdate);		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		override protected function configUI():void		{			super.configUI();			tabChildren = true;						_tf = new TextField();			addChild(_tf);						updateTextFieldType();						_vScrollBar = new UIScrollBar();			_vScrollBar.name = "V";			_vScrollBar.visible = false;			_vScrollBar.focusEnabled = false;			_vScrollBar.addEventListener(ScrollEvent.SCROLL, onScroll, false, 0, true);			copyStylesToChild(_vScrollBar, SCROLL_BAR_STYLES);			addChild(_vScrollBar);						_hScrollBar = new UIScrollBar();			_hScrollBar.name = "H";			_hScrollBar.visible = false;			_hScrollBar.focusEnabled = false;			_hScrollBar.direction = ScrollBarDirection.HORIZONTAL;			_hScrollBar.addEventListener(ScrollEvent.SCROLL, onScroll, false, 0, true);			copyStylesToChild(_hScrollBar, SCROLL_BAR_STYLES);			addChild(_hScrollBar);						_tf.addEventListener(TextEvent.TEXT_INPUT, onTextInput, false, 0, true);			_tf.addEventListener(Event.CHANGE, onChange, false, 0, true);			_tf.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown, false, 0, true);						_hScrollBar.scrollTarget = _tf;			_vScrollBar.scrollTarget = _tf;						addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheel, false, 0, true);		}						/**		 * @private		 */		override protected function draw():void		{			if (isInvalid(InvalidationType.STATE)) updateTextFieldType();						if (isInvalid(InvalidationType.STYLES))			{				setStyles();				setEmbedFont();			}						if (isInvalid(InvalidationType.STYLES, InvalidationType.STATE))			{				drawTextFormat();				drawBackground();				invalidate(InvalidationType.SIZE, false);			}						if (isInvalid(InvalidationType.SIZE, InvalidationType.DATA)) drawLayout();			super.draw();		}						/**		 * @private		 */		override protected function isOurFocus(target:DisplayObject):Boolean		{			return target == _tf || super.isOurFocus(target);		}						/**		 * @private		 */		protected function updateTextFieldType():void		{			_tf.type = (enabled && _isEditable) ? TextFieldType.INPUT : TextFieldType.DYNAMIC;			_tf.selectable = enabled;			_tf.wordWrap = _isWordWrap;			_tf.multiline = true;		}						/**		 * @private		 */		protected function setEmbedFont():void		{			_tf.embedFonts = getStyleValue("embedFonts") as Boolean;		}						/**		 * @private		 */		protected function setStyles():void		{			copyStylesToChild(_vScrollBar, SCROLL_BAR_STYLES);			copyStylesToChild(_hScrollBar, SCROLL_BAR_STYLES);		}						/**		 * @private		 */		protected function drawTextFormat():void		{			/* Apply a default textformat */			var uiStyles:Object = UIComponent.styleDefinition;			var defaultFormat:TextFormat = enabled				? uiStyles["defaultTextFormat"] as TextFormat				: uiStyles["defaultDisabledTextFormat"] as TextFormat;			_tf.setTextFormat(defaultFormat);						var f:TextFormat = getStyleValue(enabled				? "textFormat"				: "disabledTextFormat") as TextFormat;						if (f) _tf.setTextFormat(f);			else f = defaultFormat;						_tf.defaultTextFormat = f;						setEmbedFont();			if (_isHTML) _tf.htmlText = _savedHTML;		}						/**		 * @private		 */		protected function drawBackground():void		{			var bg:DisplayObject = _bg;			var styleName:String = (enabled) ? "upSkin" : "disabledSkin";			_bg = getDisplayObjectInstance(getStyleValue(styleName));						if (_bg) addChildAt(_bg, 0);			if (bg && bg != _bg && contains(bg)) removeChild(bg);		}						/**		 * @private		 */		protected function drawLayout():void		{			var padding:Number = getStyleValue("textPadding") as Number;			_tf.x = _tf.y = padding;			_bg.width = width;			_bg.height = height;			/* Figure out which scrollbars we need */			var availHeight:Number = height;			var vScrollBar:Boolean = needVScroll();			var availWidth:Number = width - (vScrollBar ? _vScrollBar.width : 0);			var hScrollBar:Boolean = needHScroll();						if (hScrollBar) availHeight -= _hScrollBar.height;			setTextSize(availWidth, availHeight, padding);						/* catch the edge case of the horizontal scroll bar necessitating a vertical one */			if (hScrollBar && !vScrollBar && needVScroll())			{				vScrollBar = true;				availWidth -= _vScrollBar.width;				setTextSize(availWidth, availHeight, padding);			}						/* Size and move the scrollBars */			if (vScrollBar)			{				_vScrollBar.visible = true;				_vScrollBar.x = width - _vScrollBar.width;				_vScrollBar.height = availHeight;				_vScrollBar.visible = true;				_vScrollBar.enabled = enabled;			}			else			{				_vScrollBar.visible = false;			}						if (hScrollBar)			{				_hScrollBar.visible = true;				_hScrollBar.y = height - _hScrollBar.height;				_hScrollBar.width = availWidth;				_hScrollBar.visible = true;				_hScrollBar.enabled = enabled;			}			else			{				_hScrollBar.visible = false;			}						updateScrollBars();			addEventListener(Event.ENTER_FRAME, onDelayedLayoutUpdate, false, 0, true);		}						/**		 * @private		 */		protected function updateScrollBars():void		{			_hScrollBar.update();			_vScrollBar.update();			_vScrollBar.enabled = enabled;			_hScrollBar.enabled = enabled;			_hScrollBar.drawNow();			_vScrollBar.drawNow();		}						/**		 * @private		 */		protected function needVScroll():Boolean		{			if (_vScrollPolicy == ScrollPolicy.OFF) return false;			if (_vScrollPolicy == ScrollPolicy.ON) return true;			return (_tf.maxScrollV > 1);		}						/**		 * @private		 */		protected function needHScroll():Boolean		{			if (_hScrollPolicy == ScrollPolicy.OFF) return false;			if (_hScrollPolicy == ScrollPolicy.ON) return true;			return (_tf.maxScrollH > 0);		}						/**		 * @private		 */		protected function setTextSize(width:Number, height:Number, padding:Number):void		{			var w:Number = width - padding * 2;			var h:Number = height - padding * 2;						if (w != _tf.width) _tf.width = w;			if (h != _tf.height) _tf.height = h;		}	}}