/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.data.structures.lists{	import com.hexagonstar.data.structures.AbstractCollection;	import com.hexagonstar.data.structures.ICollection;	import com.hexagonstar.data.structures.IIterator;			/**	 * SinglyLinkedList Class	 */	public class SinglyLinkedList extends AbstractList implements IList	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _first:Node;		protected var _last:Node;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new SinglyLinkedList instance. If any elements are		 * specified, they are being added to the new List. Otherwise an		 * empty List is created.		 * 		 * @param elements Elements to add to the List.		 */		public function SinglyLinkedList(...elements)		{			_size = 0;			_first = null;			_last = null;						if (elements.length > 0) append.apply(this, elements);		}						////////////////////////////////////////////////////////////////////////////////////////		// Query Operations                                                                   //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns the element from the List that is at the specified index.		 * 		 * @param index The index in the List from where the element should		 *         be returned.		 * @return The element that is at the specified index.		 * 		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          the specified index is not in range, i.e. it is greater than the		 *          List's size or lower than 0.		 */		public function getElementAt(index:int):*		{			if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else			{				var current:Node = _first;				var i:int = 0;				while (i < index)				{					current = current.next;					i++;				}				return current.data;			}		}						/**		 * Checks if the List contains the specified element. If the element		 * exists in the List, true is returned, otherwise false.		 * 		 * @param element The element whose presence in the List is to be tested.		 * @return true if the List contains the specified element, otherwise false.		 */		override public function contains(element:*):Boolean		{			if (_size < 1) return false;						var node:Node = _first;			while (node)			{				if (node.data === element) return true;				node = node.next;			}			return false;		}						/**		 * Returns an Iterator to iterate over the List's elements.		 * 		 * @return an Iterator to iterate over the List's elements.		 */		public function iterator():IIterator		{			return new ListIterator(this);		}						/**		 * Returns the index of the specified element in the List. If the		 * specified element was not found in the List -1 is returned.		 * 		 * @param element The element from which to return the index.		 * @return The index value of the specified element or -1 if the		 *          element was not found in the List.		 */		public function indexOf(element:*):int		{			var current:Node = _first;			var i:int = 0;						while (i < _size)			{				if (current.data === element) return i;				current = current.next;				i++;			}			return -1;		}						/**		 * Returns a String that contains the List elements joined together with		 * the specified separator String.		 * 		 * @param separator A String with that the joined elements are separated.		 * @return A String that contains the joined List elements or an empty		 *          String if the List is empty.		 */		public function join(separator:String = ","):String		{			if (_size < 1) return "";			var s:String = "";			var node:Node = _first;			var i:int = 0;						while (node)			{				s += "" + node.data;				if (i < _size - 1) s += separator;				node = node.next;				i++;			}			return s;		}						/**		 * Returns a clone of the List. The clone will be safe for use in		 * that it doesn't maintain any reference to the original List.		 * 		 * @return A clone of the List.		 */		public function clone():*		{			var list:SinglyLinkedList = new SinglyLinkedList();			list.addAll(this);			return list;		}						/**		 * Returns an Array that contains all of the elements that are		 * currently in the List. The returned Array will be safe in that		 * no references to it are maintained by the List.		 *		 * @return An Array containing all of the elements in the List.		 */		public function toArray():Array		{			var a:Array = [];			var node:Node = _first;						while (node)			{				a.push(node.data);				node = node.next;			}			return a;		}						/**		 * Returns a String Representation of the List contents		 * that can be used for debugging purposes.		 * 		 * @return A String Representation of the List contents.		 */		public function dump():String		{			var s:String = toString();			var node:Node = _first;			var i:int = 0;						while (node)			{				s += "\n[" + i + ": " + node.data + "]";				if (node.next) s += " -> ";				node = node.next;				i++;			}						return s;		}						////////////////////////////////////////////////////////////////////////////////////////		// Modification Operations                                                            //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Adds the specified element to the end of the List. This does the same		 * like calling append() with only one parameter. This methods exists here		 * merely for the purpose to follow the Collection interface.		 * 		 * @param element The element to add to the List.		 * @return true if the element was added successfully.		 */		public function add(element:*):Boolean		{			return append(element);		}						/**		 * Appends all specified elements to the end of the list.		 * 		 * @param elements The element(s) to append to the List.		 * @return true if the elements were appended successfully.		 */		public function append(...elements):Boolean		{			var l:int = elements.length;			if (l < 1) return false;			var node:Node = new Node(elements[0]);						if (_first)			{				_last.next = node;				_last = node;			}			else			{				_first = _last = node;			}						if (l > 1)			{				for (var i:int = 1; i < l; i++)				{					node = new Node(elements[i]);					_last.next = node;					_last = node;				}			}						_size += l;			return true;		}						/**		 * Adds one or more specified elements to the front of the List.		 * 		 * @param elements The element(s) to prepend to the List.		 * @return true if the elements were prepended successfully.		 */		public function prepend(...elements):Boolean		{			var l:int = elements.length;			if (l < 1) return false;			var node:Node = new Node(elements[int(l - 1)]);						if (_first)			{				node.next = _first;				_first = node;			}			else			{				_first = _last = node;			}						if (l > 1)			{				for (var i:int = l - 2; i >= 0; i--)				{					node = new Node(elements[i]);					node.next = _first;					_first = node;				}			}						_size += l;			return true;		}						/**		 * Inserts the specified element into the List at the specified index.		 * If the index is 0 or smaller the element is prepended, if the index		 * is equal or larger to the List's size the element is appended.		 * Any element that was on the specified index is being pushed to the		 * next index.		 * 		 * @param index   The index at which to insert the element.		 * @param element The element to insert.		 * @return true if the element was inserted successfully.		 */		public function insert(index:int, element:*):Boolean		{			if (index >= _size)			{				return append(element);			}			else if (index <= 0)			{				return prepend(element);			}			else			{				var node:Node = new Node(element);				var current:Node = _first;				var prev:Node;				var i:int = 0;								while (i < index)				{					prev = current;					current = current.next;					i++;				}								prev.next = node;				node.next = current;				_size++;								return true;			}		}						/**		 * Replaces the element in the List at the specified index with the		 * specified element and returns the element that has been replaced		 * or undefined if the List is empty.		 * 		 * @param index   The index at that the specified element should be placed.		 * @param element The replacing element.		 * @return the element that was orignially at the specified index or		 *          undefined if the List is empty.		 * 		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          the specified index is not in range, e.g. it is greater than the		 *          list's size or lower than 0.		 */		public function replace(index:int, element:*):*		{			if (_size < 1)			{				return undefined;			}			if (index < 0 || index >= _size)			{				throwIndexOutOfBoundsException(index);				return null;			}			else			{				var node:Node = new Node(element);				var current:Node = _first;				var prev:Node;				var i:int = 0;								/* Replace first */				if (index == 0)				{					node.next = _first.next;					_first = node;				}				/* Replace last */				else if (index == _size - 1)				{					while (i < _size - 2)					{						current = current.next;						prev = current;						i++;					}					current = _last;					node.next = null;					_last = node;					prev.next = _last;				}				/* Replace somewhere between first and last */				else				{					while (i < index)					{						prev = current;						current = current.next;						i++;					}										prev.next = node;					node.next = current.next;				}								return current.data;			}		}						/**		 * Removes the specified element from the List and returns it or		 * undefined if the element was not found in the List or if the		 * List is empty.		 * 		 * @param element The element that should be removed from the List.		 * @return the removed element or undefined if the element was not		 *          found in the List or if the List is empty.		 */		public function remove(element:*):*		{			if (_size < 1) return undefined;						if (element === _first.data)				return removeFirst();			else if (element === _last.data)				return removeLast();						var node:Node = _first;			var i:int = 0;						while (i < _size - 2)			{				i++;				node = node.next;				if (node.data === element) return removeByIndex(i);			}						return undefined;		}						/**		 * Removes the element at the specified index from the List and		 * returns it or undefined if the List is empty.		 * 		 * @param index The index from which the element should be removed.		 * @return the removed element or undefined if the List is empty.		 * 		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          the specified index is not in range, i.e. it is greater than the		 *          list's size or lower than 0.		 */		public function removeByIndex(index:int):*		{			if (_size < 1)			{				return undefined;			}			if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else if (index == 0)			{				return removeFirst();			}			else if (index == _size - 1)			{				return removeLast();			}			else			{				var current:Node = _first;				var prev:Node;				var i:int = 0;								while (i < index)				{					prev = current;					current = current.next;					i++;				}								var node:Node = current;				prev.next = current.next;				_size--;				return node.data;			}		}						/**		 * Removes the element that is at the beginning of the List and returns		 * it or undefined if the List is empty.		 * 		 * @return the removed element or undefined if the List is empty.		 */		public function removeFirst():*		{			if (_size < 1) return undefined;						var node:Node = _first;			if (_first.next == null) _last = null;			_first = _first.next;			_size--;			return node.data;		}						/**		 * Removes the element that is at the end of the List and returns it		 * or undefined if the list is empty.		 * 		 * @return the removed element or undefined if the List is empty.		 */		public function removeLast():*		{			if (_size < 1) return undefined;						var node:Node = _last;			if (_first.next == null)			{				_first = null;			}			else			{				var prev:Node = _first;				while (prev.next != _last)				{					prev = prev.next;				}								_last = prev;				prev.next = null;			}						_size--;			return node.data;		}						////////////////////////////////////////////////////////////////////////////////////////		// Bulk Operations                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Adds all of the elements in the specified Collection to the end of		 * the List and returns true if the elements were added successfully or		 * false if no elements were added, e.g. if the specified collection is empty.		 *		 * @param collection The Collection whose elements should be added to the List.		 * @return true if the elements of the specified Collection were added successfully.		 * 		 * @throws com.hexagonstar.env.exception.NullReferenceException if the		 *          specified Collection is null.		 */		public function addAll(collection:ICollection):Boolean		{			if (collection)			{				if (collection.size < 1) return false;								var a:Array = collection.toArray();				var l:int = a.length;								for (var i:int = 0; i < l; i++)				{					append(a[i]);				}								return true;			}			else			{				return throwNullReferenceException();			}		}						/**		 * Inserts all elements contained in the specified Collection to the List		 * starting at the specified index. Elements that are at an affected index		 * are shifted to the right by the size of the specified Collection. If the		 * specified index is equal to or larger than the List's size the elements		 * are added to the end of the List.		 * 		 * @param index The index to start the insertion at.		 * @param collection The Collection from which the elements to insert.		 * @return true if the elements of the specified Collection were inserted		 *          successfully or false if the Collection is empty.		 * 		 * @throws com.hexagonstar.env.exception.NullReferenceException if the		 *          specified Collection is null.		 */		public function insertAll(index:int, collection:ICollection):Boolean		{			if (collection)			{				if (collection.size < 1) return false;								var a:Array = collection.toArray();				var l:int = a.length;				for (var i:int = 0; i < l; i++)				{					insert(i + index, a[i]);				}				return true;			}			else			{				return throwNullReferenceException();			}		}						/**		 * Replaces all elements in the List with the elements in the specified		 * Collection starting from the specified List index. The elements that		 * were originally at the specified index and following indices will be		 * overwritten. This method only overwrites existing index-element pairs.		 * If an affected index is equal to or greater than the List's size,		 * which would mean that this List's size had to be expanded, an		 * IndexOutOfBoundsException will be thrown. In such a case use the		 * insertAll method instead, which expands the List dynamically.		 * 		 * @param index The index to start the replacing at.		 * @param collection The Collection with replacing elements.		 * @return true if the elements of the specified Collection were inserted		 *          successfully or false if the Collection is empty.		 * 		 * @throws com.hexagonstar.env.exception.NullReferenceException if the		 *          specified Collection is null.		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          any affected index, that is the specified index plus the index of		 *          the specific value in the specified Collection, is equal to or		 *          greater than the List's size.		 */		public function replaceAll(index:int, collection:ICollection):Boolean		{			if (!collection)			{				return throwNullReferenceException();			}			else if (index + collection.size > _size)			{				return throwIndexOutOfBoundsException2(index, collection.size);			}			else			{				if (collection.size < 1) return false;								var a:Array = collection.toArray();				var l:int = a.length;				for (var i:int = 0; i < l; i++)				{					replace(index++, a[i]);				}				return true;			}		}						/**		 * Removes all of the List's elements that are also contained in the		 * specified Collection. After the call to this method returns, the		 * List will contain no elements in common with the elements of the		 * specified Collection.		 *		 * @param collection The Collection with elements that should be		 *         removed from the List.		 * @return true if any elements were removed from the List, false if		 *          not or if the operation failed.		 *		 * @throws com.hexagonstar.env.exception.NullReferenceException if the		 *          specified Collection is null.		 */		public function removeAll(collection:ICollection):Boolean		{			if (collection)			{				var oldSize:int = _size;				var a:Array = collection.toArray();				var l:int = a.length;				for (var i:int = 0; i < l; i++)				{					remove(a[i]);				}				return (_size < oldSize);			}			else			{				return throwNullReferenceException();			}		}						/**		 * Retains only the elements in the List that are contained in the		 * specified Collection. In other words, removes all elements from the		 * List that are not contained in the specified Collection.		 *		 * @param collection The Collection with elements that should be		 *         retained in the List.		 * @return true if any elements were removed from the List, false if		 *          not or if the operation failed.		 *		 * @throws com.hexagonstar.env.exception.NullReferenceException if the		 *          specified Collection is null.		 */		public function retainAll(collection:ICollection):Boolean		{			if (collection)			{				var oldSize:int = _size;				var i:int = _size;				while (--i - (-1))				{					if (!collection.contains(getElementAt(i))) removeByIndex(i);				}				return (_size < oldSize);			}			else			{				return throwNullReferenceException();			}		}						/**		 * Removes all of the elements from the List. The List will be		 * empty after a call to this method returns.		 */		public function clear():void		{			var node:Node = _first;			_first = null;						var next:Node;			while (node)			{				next = node.next;				node.next = null;				node = next;			}			_size = 0;		}	}}// ---------------------------------------------------------------------------------------------/** * Node Class for SinglyLinkedList *  * @private */internal class Node{	public var data:*;	public var next:Node;		/**	 * Constructs a new Node instance for the SinglyLinkedList.	 * @param d the content data for the Node object.	 */	public function Node(d:*)	{		data = d;		next = null;	}}