/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.data.structures.lists{	import com.hexagonstar.data.structures.ICollection;	import com.hexagonstar.data.structures.IIterator;			/**	 * DLinkedList Class	 */	public class DLinkedList extends AbstractList implements IList	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _first:Node;		protected var _last:Node;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new DLinkedList instance.		 */		public function DLinkedList(...elements)		{			_size = 0;			_first = _last = null;						if (elements.length > 0) append.apply(this, elements);		}						////////////////////////////////////////////////////////////////////////////////////////		// Query Operations                                                                   //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns the element from the List that is at the specified index.		 * 		 * @param index The index in the List from where the element should		 *         be returned.		 * @return The element that is at the specified index.		 * 		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          the specified index is not in range, i.e. it is greater than the		 *          List's size or lower than 0.		 */		override public function getElementAt(index:int):*		{			if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else			{				var current:Node = _first;				var i:int = 0;				while (i < index)				{					current = current.next;					i++;				}				return current.data;			}		}						/**		 * Checks if the List contains the specified element. If the element		 * exists in the List, true is returned, otherwise false.		 * 		 * @param element The element whose presence in the List is to be tested.		 * @return true if the List contains the specified element, otherwise false.		 */		override public function contains(element:*):Boolean		{			if (_size < 1) return false;						var node:Node = _first;			while (node)			{				if (node.data === element) return true;				node = node.next;			}			return false;		}						/**		 * Checks if the List is equal to the specified list.		 * 		 * @param list The list to be chacked against this list.		 * @return true if both lists are equal, false if not.		 */		public function equals(list:ICollection):Boolean		{			if (list is DLinkedList)			{				var l:DLinkedList = list as DLinkedList;				var i:int = l.size;				if (i != _size) return false;								while (i--)				{					if (l.getElementAt(i) != getElementAt(i)) return false;				}								return true;			}						return false;		}						/**		 * Returns an Iterator to iterate over the List's elements.		 * 		 * @return an Iterator to iterate over the List's elements.		 */		public function iterator():IIterator		{			return new ListIterator(this);		}						/**		 * Returns the index of the specified element in the List. If the		 * specified element was not found in the List -1 is returned.		 * 		 * @param element The element from which to return the index.		 * @return The index value of the specified element or -1 if the		 *          element was not found in the List.		 */		public function indexOf(element:*):int		{			var current:Node = _first;			var i:int = 0;						while (i < _size)			{				if (current.data === element) return i;				current = current.next;				i++;			}			return -1;		}						/**		 * Returns a String that contains the List elements joined together with		 * the specified separator String.		 * 		 * @param separator A String with that the joined elements are separated.		 * @return A String that contains the joined List elements or an empty		 *          String if the List is empty.		 */		public function join(separator:String = ","):String		{			if (_size < 1) return "";			var s:String = "";			var node:Node = _first;			var i:int = 0;						while (node)			{				s += "" + node.data;				if (i < _size - 1) s += separator;				node = node.next;				i++;			}			return s;		}						/**		 * Returns a clone of the List. The clone will be safe for use in		 * that it doesn't maintain any reference to the original List.		 * 		 * @return A clone of the List.		 */		public function clone():*		{			var list:DLinkedList = new DLinkedList();			list.addAll(this);			return list;		}						/**		 * Returns an Array that contains all of the elements that are		 * currently in the List. The returned Array will be safe in that		 * no references to it are maintained by the List.		 *		 * @return An Array containing all of the elements in the List.		 */		public function toArray():Array		{			var a:Array = [];			var node:Node = _first;						while (node)			{				a.push(node.data);				node = node.next;			}			return a;		}						/**		 * Returns a String Representation of the List contents		 * that can be used for debugging purposes.		 * 		 * @return A String Representation of the List contents.		 */		public function dump():String		{			var s:String = toString();			var node:Node = _first;			var i:int = 0;						while (node)			{				s += "\n" + (i < 10 ? " " : "") + "[" + i + ": " + node.toString() + "]";				if (node.prev && node.next) s += " <> ";				else if (node.prev) s += " < ";				else if (node.next) s += " > ";				node = node.next;				i++;			}						return s;		}						////////////////////////////////////////////////////////////////////////////////////////		// Modification Operations                                                            //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Adds the specified element to the end of the List. This does the same		 * like calling append() with only one parameter. This methods exists here		 * merely for the purpose to follow the Collection interface.		 * 		 * @param element The element to add to the List.		 * @return true if the element was added successfully.		 */		public function add(element:*):Boolean		{			return append(element);		}						/**		 * Appends all specified elements to the end of the list.		 * 		 * @param elements The element(s) to append to the List.		 * @return true if the elements were appended successfully.		 */		override public function append(...elements):Boolean		{			var l:int = elements.length;			if (l < 1) return false;						var node:Node = new Node(elements[0]);						if (_first)			{				_last.next = node;				node.prev = _last;				_last = node;			}			else			{				_first = _last = node;			}						if (l > 1)			{				for (var i:int = 1; i < l; i++)				{					node = new Node(elements[i]);					_last.next = node;					node.prev = _last;					_last = node;				}			}						_size += l;			return true;		}						/**		 * Adds one or more specified elements to the front of the List.		 * 		 * @param elements The element(s) to prepend to the List.		 * @return true if the elements were prepended successfully.		 */		public function prepend(...elements):Boolean		{			var l:int = elements.length;			if (l < 1) return false;			var node:Node = new Node(elements[int(l - 1)]);						if (_first)			{				_first.prev = node;				node.next = _first;				_first = node;			}			else			{				_first = _last = node;			}						if (l > 1)			{				for (var i:int = l - 2; i >= 0; i--)				{					node = new Node(elements[i]);					_first.prev = node;					node.next = _first;					_first = node;				}			}						_size += l;			return true;		}						/**		 * Inserts the specified element into the List at the specified index.		 * If the index is 0 or smaller the element is prepended, if the index		 * is equal or larger to the List's size the element is appended.		 * Any element that was on the specified index is being pushed to the		 * next index.		 * 		 * @param index   The index at which to insert the element.		 * @param element The element to insert.		 * @return true if the element was inserted successfully.		 */		override public function insert(index:int, element:*):Boolean		{			if (index >= _size)			{				return append(element);			}			else if (index <= 0)			{				return prepend(element);			}			else			{				var node:Node = new Node(element);				var current:Node = _first;				var prev:Node;				var i:int = 0;								while (i < index)				{					prev = current;					current = current.next;					i++;				}								prev.next = node;				node.prev = prev;				node.next = current;				current.prev = node;								_size++;				return true;			}		}						/**		 * Replaces the element in the List at the specified index with the		 * specified element and returns the element that has been replaced		 * or undefined if the List is empty.		 * 		 * @param index   The index at that the specified element should be placed.		 * @param element The replacing element.		 * @return the element that was orignially at the specified index or		 *          undefined if the List is empty.		 * 		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          the specified index is not in range, e.g. it is greater than the		 *          list's size or lower than 0.		 */		override public function replace(index:int, element:*):*		{			if (_size < 1)			{				return undefined;			}			if (index < 0 || index >= _size)			{				throwIndexOutOfBoundsException(index);				return null;			}			else			{				var node:Node = new Node(element);				var current:Node = _first;								/* Replace first */				if (index == 0)				{					node.next = _first.next;					node.next.prev = node;					_first = node;				}				/* Replace last */				else if (index == _size - 1)				{					current = _last;					node.prev = _last.prev;					_last.prev.next = node;					_last = node;				}				/* Replace somewhere between first and last */				else				{					var prev:Node;					var i:int = 0;					while (i < index)					{						prev = current;						current = current.next;						i++;					}										prev.next = node;					node.prev = prev;					node.next = current.next;					node.next.prev = node;				}								return current.data;			}		}						/**		 * Removes the specified element from the List and returns it or		 * undefined if the element was not found in the List or if the		 * List is empty.		 * 		 * @param element The element that should be removed from the List.		 * @return the removed element or undefined if the element was not		 *          found in the List or if the List is empty.		 */		override public function remove(element:*):*		{			if (_size < 1) return undefined;						if (element === _first.data)				return removeFirst();			else if (element === _last.data)				return removeLast();						var node:Node = _first;			var i:int = 0;						while (i < _size - 2)			{				i++;				node = node.next;				if (node.data === element) return removeByIndex(i);			}						return undefined;		}						/**		 * Removes the element at the specified index from the List and		 * returns it or undefined if the List is empty.		 * 		 * @param index The index from which the element should be removed.		 * @return the removed element or undefined if the List is empty.		 * 		 * @throws com.hexagonstar.env.exception.data.IndexOutOfBoundsException if		 *          the specified index is not in range, i.e. it is greater than the		 *          list's size or lower than 0.		 */		override public function removeByIndex(index:int):*		{			if (_size < 1)			{				return undefined;			}			if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else if (index == 0)			{				return removeFirst();			}			else if (index == _size - 1)			{				return removeLast();			}			else			{				var current:Node = _first;				var prev:Node;				var i:int = 0;								while (i < index)				{					prev = current;					current = current.next;					i++;				}								var node:Node = current;				prev.next = current.next;				current.next.prev = prev;				_size--;				return node.data;			}		}						/**		 * Removes the element that is at the beginning of the List and returns		 * it or undefined if the List is empty.		 * 		 * @return the removed element or undefined if the List is empty.		 */		public function removeFirst():*		{			if (_size < 1) return undefined;						var node:Node = _first;			if (_first.next == null)			{				_first = _last = null;			}			else			{				_first.next.prev = null;				_first = _first.next;			}						_size--;			return node.data;		}						/**		 * Removes the element that is at the end of the List and returns it		 * or undefined if the list is empty.		 * 		 * @return the removed element or undefined if the List is empty.		 */		public function removeLast():*		{			if (_size < 1) return undefined;						var node:Node = _last;			if (_first.next == null)			{				_first = null;			}			else			{				_last.prev.next = null;				_last = _last.prev;			}						_size--;			return node.data;		}						////////////////////////////////////////////////////////////////////////////////////////		// Bulk Operations                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Removes all of the elements from the List. The List will be		 * empty after a call to this method returns.		 */		public function clear():void		{			var node:Node = _first;			_first = null;						var next:Node;			while (node)			{				next = node.next;				node.next = node.prev = null;				node = next;			}			_size = 0;		}	}}// ---------------------------------------------------------------------------------------------/** * Node Class for DLinkedList *  * @private */internal class Node{	public var data:*;	public var next:Node;	public var prev:Node;		/**	 * Constructs a new Node instance for the DLinkedList.	 * @param d the content data for the Node object.	 */	public function Node(d:*)	{		data = d;		next = prev = null;	}		/**	 * For Debugging only!	 */	public function toString():String	{		var p:String = (prev) ? prev.data : "NULL";		var n:String = (next) ? next.data : "NULL";		return data + "   P:[" + p + "]  N:[" + n + "]";	}}