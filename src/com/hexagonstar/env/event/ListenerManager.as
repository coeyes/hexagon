/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.env.event{	import com.hexagonstar.env.AbstractDisposable;		import flash.events.Event;	import flash.events.IEventDispatcher;	import flash.utils.Dictionary;			/**	 * ListenerManager Class	 */	public class ListenerManager extends AbstractDisposable		implements IRemovableEventDispatcher	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected static var _proxyMap:Dictionary;		protected var _eventDispatcher:IEventDispatcher;		protected var _events:Vector.<EventInfo>;		protected var _blockRequest:Boolean;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @exclude		 */		public function ListenerManager(singletonEnforcer:EventInfo,			dispatcher:IEventDispatcher) 		{			super();						_eventDispatcher = dispatcher;			_events = new Vector.<EventInfo>();		}						/**		 * Registers a IEventDispatcher to be managed by ListenerManager.		 * 		 * @param dispatcher The IEventDispatcher instance to manage.		 * @return A ListenerManager instance.		 */		public static function getManager(dispatcher:IEventDispatcher):ListenerManager 		{			if (!_proxyMap) _proxyMap = new Dictionary();						if (!_proxyMap[dispatcher])				_proxyMap[dispatcher] = new ListenerManager(new EventInfo(null, null, false),					dispatcher);						return _proxyMap[dispatcher];		}						/**		 * Notifies the ListenerManager instance that a listener has been added		 * to the IEventDispatcher.		 * 		 * @param type The type of event.		 * @param listener The listener function that processes the event.		 * @param useCapture Determines whether the listener works in the capture		 *         phase or the target and bubbling phases.		 * @param priority The priority level of the event listener.		 * @param useWeakReference Determines whether the reference to the		 *         listener is strong or weak.		 */		public function addEventListener(type:String,											listener:Function,											useCapture:Boolean = false,											priority:int = 0,											useWeakReference:Boolean = false):void 		{			var info:EventInfo = new EventInfo(type, listener, useCapture);			var l:int = _events.length;						while (l--)			{				if (_events[l].equals(info)) return;			}						_events.push(info);		}						/**		 * Notifies the ListenerManager instance that a listener has been		 * removed from the IEventDispatcher.		 * 		 * @param type The type of event.		 * @param listener The listener function that processes the event.		 * @param useCapture Determines whether the listener works in the		 *         capture phase or the target and bubbling phases.		 */		public function removeEventListener(type:String, listener:Function,			useCapture:Boolean = false):void		{			if (_blockRequest) return;						var info:EventInfo = new EventInfo(type, listener, useCapture);			var l:int = _events.length;						while (l--)			{				if (_events[l].equals(info)) _events.splice(l, 1);			}		}						/**		 * Removes all event listeners.		 */		public function removeEventListeners():void		{			_blockRequest = true;						var info:EventInfo;			var l:int = _events.length;						while (l--)			{				info = _events.splice(l, 1)[0];				_eventDispatcher.removeEventListener(info.type, info.listener, info.useCapture);			}						_blockRequest = false;		}						/**		 * Removes all events that report to the specified listener.		 * 		 * @param listener The listener function that processes the event.		 */		public function removeEventsForListener(listener:Function):void 		{			_blockRequest = true;						var info:EventInfo;			var l:int = _events.length;						while (l--)			{				info = _events[l];								if (info.listener == listener)				{					_events.splice(l, 1);					_eventDispatcher.removeEventListener(info.type, info.listener,						info.useCapture);				}			}						_blockRequest = false;		}						/**		 * Removes all events of a specific type.		 * 		 * @param type The type of event.		 */		public function removeEventsForType(type:String):void 		{			_blockRequest = true;						var info:EventInfo;			var l:int = _events.length;						while (l--)			{				info = _events[l];								if (info.type == type)				{					_events.splice(l, 1);					_eventDispatcher.removeEventListener(info.type, info.listener,						info.useCapture);				}			}						_blockRequest = false;		}						/**		 * Disposes the ListenerManager.		 */		override public function dispose():void		{			removeEventListeners();			delete ListenerManager._proxyMap[_eventDispatcher];			_eventDispatcher = null;			super.dispose();		}						/**		 * @exclude		 */		public function dispatchEvent(event:Event):Boolean 		{			return _eventDispatcher.dispatchEvent(event);		}						/**		 * @exclude		 */		public function hasEventListener(type:String):Boolean 		{			return _eventDispatcher.hasEventListener(type);		}						/**		 * @exclude		 */		public function willTrigger(type:String):Boolean 		{			return _eventDispatcher.willTrigger(type);		}	}}/* ------------------------------------------------------------------------------------------- *//** * EventInfo Object Class */class EventInfo {	public var type:String;	public var listener:Function;	public var useCapture:Boolean;			public function EventInfo(type:String, listener:Function, useCapture:Boolean)	{		this.type = type;		this.listener = listener;		this.useCapture = useCapture;	}			public function equals(eventInfo:EventInfo):Boolean	{		return (type == eventInfo.type && listener == eventInfo.listener			&& useCapture == eventInfo.useCapture);	}}