/* * rhombus - Application framework for web/desktop-based Flash & Flex projects. *  *  /\ RHOMBUS *  \/ FRAMEWORK *  * Licensed under the MIT License * Copyright (c) 2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.framework.env.cli{	import command.env.CloseApplicationCommand;	import com.hexagonstar.data.types.Byte;	import com.hexagonstar.data.types.Time;	import com.hexagonstar.display.text.ColumnText;	import com.hexagonstar.event.CommandEvent;	import com.hexagonstar.framework.command.file.LoadLocaleCommand;	import com.hexagonstar.framework.managers.CommandManager;	import com.hexagonstar.framework.util.Log;	import com.hexagonstar.framework.view.console.Console;	import com.hexagonstar.framework.view.console.FPSMonitor;	import com.hexagonstar.time.Interval;	import flash.display.StageDisplayState;	import flash.system.Capabilities;	import flash.system.System;	import flash.utils.describeType;	import flash.utils.getTimer;		/**	 * Handles the execution of commands entered into the Console CLI. This class	 * provides a default set of Console commands but can be extended to implement	 * application-specific commands or functions. The extending handler class must	 * then implement the ICLICommandInvoker marker interface.	 * 	 * @author Sascha Balkau	 * @version 1.0.1	 */	public class CLICommandInvoker	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		protected var _console:Console;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new CLICommandInvoker instance.		 */		public function CLICommandInvoker()		{		}				/**		 * consoleMessage		 */		public function consoleMessage(msg:String, level:int = 2):void		{			_console.log(msg, level);		}						/**		 * consoleClear		 */		public function consoleClear():void		{			_console.clear();		}						/**		 * consoleHide		 */		public function consoleHide():void		{			_console.clearInput();			_console.toggle();		}						/**		 * consoleHelp		 */		public function consoleHelp():void		{			var cmds:Vector.<CLICommand> = Console.cli.commands;			var s:String = "\nConsole Commands:\n";			var t:ColumnText = new ColumnText(2, "  ", true);						for each (var c:CLICommand in cmds)			{				var f:String = c.command + "(";				if (c.signature)				{					for each (var a:String in c.signature)					{						f += a + ", ";					}					f = f.substr(0, f.length - 2);				}				t.add(["\t" + f + ")", c.help]);			}			_console.log(s + t.toString());		}						/**		 * consoleMem		 */		public function consoleMem():void		{			_console.log("Memory used: " + new Byte(System.totalMemory).toString());		}						/**		 * consoleMeta		 */		public function consoleMeta():void		{			var x:XML = describeType(AppInfo);			var t:ColumnText = new ColumnText(2, " ", true);			for each (var a:XML in x.factory.accessor)			{				t.add([a.@name + ":", Main.appInfo[a.@name]]);			}			_console.log("\n" + t.toString());		}						/**		 * consoleTime		 */		public function consoleTime():void		{			_console.log("Running since " + new Time(getTimer()).toString());		}						/**		 * consoleBuffer		 */		public function consoleBuffer():void		{			_console.log("Current buffer size: " + _console.bufferSize + "/"				+ _console.maxBufferSize + " bytes");		}						/**		 * consoleGC		 */		public function consoleGC():void		{			var a:String = new Byte(System.totalMemory).toString();			System.gc();			Interval.setTimeOut(onGCDone, 2000, a).start();		}						/**		 * consoleFull		 */		public function consoleFull():void		{			_console.toggleSize();		}						/**		 * consoleRuntime		 */		public function consoleRuntime():void		{			var d:String = Capabilities.isDebugger.toString();			var t:String = Capabilities.playerType;			var v:String = Capabilities.version;			var a:Array = v.split(" ");			var p:String = a.shift();			a = String(a[0]).split(",");			v = a[0] + "." + a[1] + "." + a[2] + " (" + a[3] + ")";			_console.log("runtime version: " + v + ", type: " + t + ", platform: " + p				+ ", debugger: " + d);		}						/**		 * appInit		 */		public function appInit():void		{			Main.instance.init();		}						/**		 * appInfo		 */		public function appInfo():void		{			_console.log(Main.appInfo.name				+ " v" + Main.appInfo.version				+ " " + Main.appInfo.releaseStage				+ " build #" + Main.appInfo.build				+ " (" + Main.appInfo.buildDate				+ ") -- copyright (c) " + Main.appInfo.copyright				+ " " + Main.appInfo.year);		}						/**		 * appFPS		 */		public function appFPSToggle():void		{			FPSMonitor.instance.toggle();		}						/**		 * appFullscreen		 */		public function appFullscreen():void		{			var state:String = Main.app.stage.displayState;						/*FDT_IGNORE*/			CONFIG::IS_AIR			/*FDT_IGNORE*/			{				if (state == StageDisplayState.FULL_SCREEN_INTERACTIVE)				{					state = StageDisplayState.NORMAL;				}				else				{					state = StageDisplayState.FULL_SCREEN_INTERACTIVE;				}				Main.app.stage.displayState = state;				return;			}						if (state == StageDisplayState.FULL_SCREEN)			{				state = StageDisplayState.NORMAL;			}			else			{				state = StageDisplayState.FULL_SCREEN;			}			Main.app.stage.displayState = state;		}						/**		 * appExit		 */		public function appExit():void		{			CommandManager.instance.execute(new CloseApplicationCommand());		}						/**		 * locale		 */		public function appLocale(localeID:String = ""):void		{			if (localeID.length > 0)			{				Main.commandManager.execute(new LoadLocaleCommand(localeID),					onLoadLocaleComplete, onLoadLocaleError);			}			else			{				Log.info("Current locale: " + Main.config.currentLocale);			}		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				public function get console():Console		{			return _console;		}		public function set console(v:Console):void		{			_console = v;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		protected function onGCDone(a:String):void		{			var b:String = new Byte(System.totalMemory).toString();			_console.log("Garbage collection executed, mem before: " + a + ", mem after: " + b);		}						/**		 * @private		 */		protected function onLoadLocaleComplete(e:CommandEvent):void		{			Main.config.currentLocale = LoadLocaleCommand(e.command).localeID;			Log.info("Locale changed to [" + Main.config.currentLocale + "].");			/* Update UI after locale was changed. */			Main.ui.update();		}						/**		 * @private		 */		protected function onLoadLocaleError(e:CommandEvent):void		{			Log.error("Error loading locale for ["				+ LoadLocaleCommand(e.command).localeID + "].");		}	}}