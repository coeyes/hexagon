/* * tetragonlib - ActionScript 3 Game Library. *    ____ *   /    / TETRAGON *  /____/  LIBRARY *  * Licensed under the MIT License *  * Copyright (c) 2009 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.game.tile{	import com.hexagonstar.display.Mask;	import com.hexagonstar.display.shapes.RectangleGradientShape;	import com.hexagonstar.game.tile.ds.PropertyMap;	import com.hexagonstar.time.PreciseTimer;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.TimerEvent;	import flash.filters.DropShadowFilter;		/**	 * TileScroller Class	 */	public class TileScroller extends Sprite	{		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////				public static const TILE_ANIM_FPS:int = 12;						////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				public var scrollLeft:Boolean;		public var scrollRight:Boolean;		public var scrollUp:Boolean;		public var scrollDown:Boolean;				protected var _view:Sprite;		protected var _mask:Mask;		protected var _background:BitmapData;				protected var _tileMap:ITileMap;		protected var _tileSets:PropertyMap;				protected var _speed:int;				protected var _xPos:int;		protected var _yPos:int;		protected var _xOld:int;		protected var _yOld:int;				protected var _tileWidth:int;		protected var _tileHeight:int;				/**		 * The width of the visible scroll field.		 * @private		 */		protected var _viewWidth:int;				/**		 * The height of the visible scroll field.		 * @private		 */		protected var _viewHeight:int;				/**		 * The number of tile columns that are visible in the scroller view.		 * @private		 */		protected var _viewCols:int;				/**		 * The number of tile rows that are visible in the scroller view.		 * @private		 */		protected var _viewRows:int;				/**		 * The with of the whole tile map, measured in tiles.		 * @private		 */		protected var _mapWidthTiles:int;				/**		 * The height of the whole tile map, measured in tiles.		 * @private		 */		protected var _mapHeightTiles:int;				/**		 * The with of the whole tile map, measured in pixel.		 * @private		 */		protected var _mapWidthPixel:int;				/**		 * The height of the whole tile map, measured in pixel.		 * @private		 */		protected var _mapHeightPixel:int;				protected var _layers:Vector.<ITileLayer>;		protected var _layerCount:int;				protected var _timer:PreciseTimer;		protected var _fps:int;		protected var _tick:int;				protected var _isMasked:Boolean = true;		protected var _isPaused:Boolean = false;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new TileScroller instance.		 * 		 * @param width The width of the scoller area, in pixels.		 * @param height The height of the scoller area, in pixels.		 */		public function TileScroller(width:int = 0, height:int = 0)		{			_viewWidth = width;			_viewHeight = height;						setup();		}						/**		 * addTileSet		 */		public function addTileSet(tileSet:TileSet):void		{			if (_tileSets.size == 0)			{				_tileWidth = tileSet.tileWidth;				_tileHeight = tileSet.tileHeight;			}						_tileSets.put(tileSet.id, tileSet);		}						/**		 * Initializes TileScroller.		 */		public function init():void		{			scrollLeft = scrollRight = scrollUp = scrollDown = false;			_tick = 0;						_speed = _tileWidth / 2;						_layers = _tileMap.layers;			_layerCount = _layers.length;						_viewCols = _viewWidth / _tileWidth;			_viewRows = _viewHeight / _tileHeight;						_xPos = 0;			_yPos = 0;			_xOld = -1;			_yOld = -1;						_tileMap.initLayers(_tileSets, _viewWidth, _viewHeight);						_mapWidthPixel = _tileMap.widthPixel;			_mapHeightPixel = _tileMap.heightPixel;						var ms:int = Math.round(1000 / _fps);			_timer = new PreciseTimer(ms, 0);			_timer.addEventListener(TimerEvent.TIMER, onTimer);		}						/**		 * start		 */		public function start():void		{			addMask();			addBackground();			addLayers();						_timer.start();		}						/**		 * stop		 */		public function stop():void		{		}						/**		 * Pauses the tile scroller.		 */		public function pause():void		{			paused = true;		}						/**		 * Returns a String Representation of TileScroller.		 * 		 * @return A String Representation of TileScroller.		 */		override public function toString():String		{			return "[TileScroller, viewCols=" + _viewCols				+ ", viewRows=" + _viewRows				+ ", mapWidthPixel=" + _mapWidthPixel				+ ", mapHeightPixel=" + _mapHeightPixel + "]";		}						/**		 * Disposes the tile scroller.		 */		public function dispose():void		{		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * The tile map used to display in the tile scroller.		 */		public function get tileMap():ITileMap		{			return _tileMap;		}		public function set tileMap(v:ITileMap):void		{			_tileMap = v;			_mapWidthTiles = _tileMap.widthTiles;			_mapHeightTiles = _tileMap.heightTiles;		}						/**		 * The FPS at that the tile scroller runs.		 */		public function get fps():int		{			return _fps;		}		public function set fps(fps:int):void		{			_fps = fps;		}						/**		 * Determines if the tile scroller area is masked or not. Mainly used for		 * debugging.		 */		public function get masked():Boolean		{			return _isMasked;		}		public function set masked(v:Boolean):void		{			_isMasked = v;		}						/**		 * Determines whether the tile scvroller is paused or not.		 */		public function get paused():Boolean		{			return _isPaused;		}		public function set paused(v:Boolean):void		{			_isPaused = v;		}						/**		 * The with of the scroller area, in pixels.		 */		override public function get width():Number		{			return _viewWidth;		}		override public function set width(v:Number):void		{			_viewWidth = v;		}						/**		 * The height of the scroller area, in pixels.		 */		override public function get height():Number		{			return _viewHeight;		}		override public function set height(v:Number):void		{			_viewHeight = v;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		protected function onTimer(e:TimerEvent):void		{			if (scrollRight) _xPos += _speed;			else if (scrollLeft) _xPos -= _speed;			if (scrollDown) _yPos += _speed;			else if (scrollUp) _yPos -= _speed;						if (_xPos < 0)			{				_xPos = 0;			}			else if (_xPos > (_mapWidthPixel - _viewWidth) - 1)			{				_xPos = (_mapWidthPixel - _viewWidth) - 1;			}						if (_yPos < 0)			{				_yPos = 0;			}			else if (_yPos > (_mapHeightPixel - _viewHeight) - 1)			{				_yPos = (_mapHeightPixel - _viewHeight) - 1;			}						if (_xPos == _xOld && _yPos == _yOld) return;						drawLayers();						_xOld = _xPos;			_yOld = _yPos;		}				////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * setup		 * @private		 */		protected function setup():void		{			_fps = 30;			_tileSets = new PropertyMap(10);			_view = new Sprite();			addChild(_view);		}						/**		 * addMask		 * @private		 */		protected function addMask():void		{			if (_isMasked)			{				_mask = new Mask(_viewWidth, _viewHeight);				_view.mask = _mask;				addChild(_mask);			}		}				/**		 * addBackground		 * @private		 */		protected function addBackground():void		{			var bgColor:uint = _tileMap.backgroundColor;			_background = new BitmapData(_viewWidth, _viewHeight, false, bgColor);						var bgGradient:String = _tileMap.properties.getValue("backgroundGradient");			if (bgGradient)			{				var a:Array = PropertyMap.parseArrayProperty(bgGradient);				if (a) _background.draw(generateGradientShape(a));			}						_view.addChild(new Bitmap(_background));		}						/**		 * addLayers		 * @private		 */		protected function addLayers():void		{			for (var i:int = 0; i < _layerCount; i++)			{				var layer:ITileLayer = _layers[i];				addLayerFilters(layer);				//layer.draw(_xPos, _yPos);				_view.addChild(layer as DisplayObject);			}		}						/**		 * drawLayers		 * @private		 */		protected function drawLayers():void		{			for (var i:int = 0; i < _layerCount; i++)			{				var layer:ITileLayer = _layers[i];				layer.draw(_xPos, _yPos);				//layer.scroll(scrollLeft, scrollRight, scrollUp, scrollDown);			}		}				/**		 * Generates a GradientShape from the specified array. The array's first		 * value is used as the gradient's rotation (in degrees) and every following		 * value is used as a color, e.g. [-90, 0xFF2233, 0x4400FF, 0x00FFFF, ...].		 * The array can have an arbitrary amount of color values.		 * @private		 * 		 * @param a The array with gradient values.		 * @return A RectangleGradientShape.		 */		protected function generateGradientShape(a:Array):RectangleGradientShape		{			var r:Number = a.shift();			var l:int = a.length;			var f:Number = (255 / (l - 1));			var ratio:Number = 0;			var ratios:Array = [];			var alphas:Array = [];						for (var i:int = 0; i < l; i++)			{				ratios.push(Math.floor(ratio));				alphas.push(1.0);				ratio += f;			}						var shape:RectangleGradientShape = new RectangleGradientShape();			shape.draw(_viewWidth, _viewHeight, r, a, alphas, ratios);			return shape;		}						/**		 * Adds filters to the specified layer.		 * @private		 */		protected function addLayerFilters(layer:ITileLayer):void		{			var filters:Array = [];						var dropShadow:String = layer.properties.getValue("dropShadow");			if (dropShadow)			{				var a:Array = PropertyMap.parseArrayProperty(dropShadow);				var dst:Number = a[0];				var ang:Number = a[1];				var col:uint = a[2];				var alp:Number = a[3];				var blX:Number = a[4];				var blY:Number = a[5];				var str:Number = a[6];				var qal:int = a[7];				var inr:Boolean = (a[8] == "true" ? true : false);				filters.push(new DropShadowFilter(dst, ang, col, alp, blX, blY, str, qal, inr));			}						if (filters.length > 0)			{				layer.filters = filters;			}		}						/**		 * drawLayerToBuffer		 * @private		 *///		protected function drawLayerToBuffer(layer:TileLayer):void//		{//			var grid:Grid2D = layer.grid;//			var tile:ITile;//			var tileID:int;//			var xPos:int;//			var yPos:int;//			//			_rectangle = new Rectangle(0, 0, _tileWidth, _tileHeight);//			//			for (var y:int = 0; y < _mapHeight; y++)//			{//				for (var x:int = 0; x < _mapWidth; x++)//				{//					tileID = grid.getCell(x, y);//					//					/* Only draw tiles if necessary *///					if (tileID > 0)//					{//						tile = _tileSet.getTile(tileID);//						_point.x = x * _tileWidth;//						_point.y = y * _tileHeight;//						//						if (tile is AnimTile)//						{//							tile = _tileSet.duplicateTile(tile);//							tile.x = _point.x;//							tile.y = _point.y;//							layer.addChild(tile as DisplayObject);//							_buffer.draw(layer);//						}//						else//						{//							_buffer.copyPixels((tile as Tile).bitmapData, _rectangle, _point);//						}//					}//				}//			}//		}						/**		 * fillBuffer - only for testing!		 * @private		 *///		private function fillBuffer():void//		{//			var tileCount:int = _tileSet.tileCount;//			var tilesH:int = Math.ceil(_buffer.width / _tileWidth);//			var tilesV:int = Math.ceil(_buffer.height / _tileHeight);//			//			_rectangle = new Rectangle(0, 0, _tileWidth, _tileHeight);//			//			for (var y:int = 0; y < tilesV; y++)//			{//				for (var x:int = 0; x < tilesH; x++)//				{//					var rnd:int = (Math.random() * tileCount) + 1;//					var tile:Tile = _tileSet.getTile(rnd) as Tile;//					//					_point.x = x * _tileWidth;//					_point.y = y * _tileHeight;//					//					if (tile is AnimTile)//					{//						tile = _tileSet.duplicateTile(tile) as Tile;//						tile.x = _point.x;//						tile.y = _point.y;//						//					}//					else//					{//						_buffer.copyPixels(tile.bitmapData, _rectangle, _point);//					}//				}//			}//			//			addChild(new Bitmap(_buffer));//			//_window.draw(_buffer);//		}	}}