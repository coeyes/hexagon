/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.io.resource{	import com.hexagonstar.core.BasicClass;	import com.hexagonstar.debug.HLog;	import com.hexagonstar.event.ResourceEvent;	import com.hexagonstar.exception.NullReferenceException;	import com.hexagonstar.io.resource.provider.FallbackResourceProvider;	import com.hexagonstar.io.resource.provider.IResourceProvider;	import com.hexagonstar.io.resource.types.Resource;	import flash.events.Event;	import flash.utils.Dictionary;	import flash.utils.setTimeout;		/**	 * The resource manager handles all tasks related to using asset files (images, xml,	 * etc) in a project. This includes loading files, managing embedded resources, and	 * cleaninp up resources no longer in use.	 * 	 * @author Sascha Balkau	 */	public class ResourceManager extends BasicClass	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		private static var _instance:ResourceManager;		/** @private */		private static var _singletonLock:Boolean = false;		        /**         * Dictionary of loaded resources indexed by resource name and type.         * @private         */        protected var _resources:Dictionary;        		/**		 * List of resource providers used to get resources.          * @private		 */        		protected var _providers:Vector.<IResourceProvider>;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new instance of the class.		 */		public function ResourceManager()		{			if (!_singletonLock)			{				throw new Error("Tried to instantiate ResourceManager through it's constructor."					+ " Use the instance property instead.");			}						_resources = new Dictionary();			_providers = new Vector.<IResourceProvider>();		}						/**		 * Loads a resource from an embedded or external file. If the resource has already		 * been loaded or is embedded, a reference to the existing resource will be given.		 * The resource is not returned directly since loading is asynchronous. Instead, it		 * will be passed to the function specified as the loadedHandler parameter. Even if		 * the resource has already been loaded, it cannot be assumed that the callback will		 * happen synchronously.		 * <p>		 * This will not attempt to load resources that have previously failed to load.		 * Instead, the load will fail instantly.		 * </p>		 * 		 * @param path The file path to the resource.		 * @param type The Resource subclass specifying the type of resource that is being		 *            requested.		 * @param loadedHandler A function that will be called on successful load of the		 *            resource. The function should take a single parameter of the type		 *            specified in the type parameter.		 * @param failedHandler A function that will be called if loading of the resource		 *            fails. The function should take a single parameter of the type		 *            specified in the type parameter. The resource passed to the function		 *            will be invalid, but the filename property will be correct.		 * @param forceReload Determines if the resource should be reloaded, even if it has		 *            already been loaded.		 * @see Resource		 */		public function load(path:String,								type:Class,								loadedHandler:Function = null,								failedHandler:Function = null,								forceReload:Boolean = false):void		{			var identifier:String = createIdentifier(path, type);			var resource:Resource = _resources[identifier];						/* If resource was loaded and we want to force a reload, do that. */			if (resource && forceReload)			{				_resources[identifier] = null;				delete _resources[identifier];				resource = null;			}						/* Resource not loaded yet, try to get it from a resource provider. */			if (!resource)			{				/* Check available resource providers and request the resource if it is known. */				for (var i:int = 0; i < _providers.length; i++)				{					if (_providers[i].isResourceKnown(path, type))					{						resource  = _providers[i].getResource(path, type, forceReload);						break;					}				}								if (!resource)				{					resource = FallbackResourceProvider.instance.getResource(path,						type, forceReload);				}								_resources[identifier] = resource;			}			else if (!(resource is type))			{				fail(resource, failedHandler, "The resource <" + path					+ "> is already loaded, but is not of type " + type + ".");				return;			}						if (resource.failed)			{				fail(resource, failedHandler, "The resource <" + path					+ "> has previously failed to load.");			}			else if (resource.loaded)			{				if (loadedHandler != null)				{					setTimeout(loadedHandler, 1, resource);				}			}			else			{				/* Still in process, so just hook up to its events. */				if (loadedHandler != null)				{					resource.addEventListener(ResourceEvent.LOADED,						function (e:Event):void {loadedHandler(resource);}, false, 0, true);				}				if (failedHandler != null)				{					resource.addEventListener(ResourceEvent.FAILED,						function (e:Event):void {failedHandler(resource);}, false, 0, true);				}			}						resource.incrementReferenceCount();		}						/**		 * Unloads a previously loaded resource. This does not necessarily mean the resource		 * will be available for garbage collection. Resources are reference counted so if		 * the specified resource has been loaded multiple times, its reference count will		 * only decrease as a result of this.		 * 		 * @param path The file path of the resource to unload.		 * @param type The type of the resource to unload.		 */		public function unload(path:String, type:Class):void		{			// TODO Right now unload is unloading embedded resources inappropriately. Since			// they are going to be in memory anyway as part of the SWF, I am disabling			// Unload for now.			// mas : we probably have to unload the resource @ the specific resourceProvider			// 		 as well! so we have to take this into account when we reactivate the			//		 unload.						return;						var identifier:String = createIdentifier(path, type);			if (!_resources[identifier])			{				HLog.warn(toString() + " The resource from file <" + path + "> of type <"					+ type + "> cannot be unloaded because it is not loaded.");				return;			}						var r:Resource = _resources[identifier];			r.decrementReferenceCount();						if (r.referenceCount < 1)			{				_resources[identifier] = null;				delete _resources[identifier];			}		}						/**		 * Registers data with the resource manager to be treated as a resource. This is		 * used by embedded resources, which is facilitated by the ResourceBinding class.		 * 		 * @param path The name to register the resource under. In the case of embedded		 *            resources, it should match the filename of the resource.		 * @param type The Resource subclass to create with the specified data.		 * @param data A byte array containing the data for the resource. This should match		 *            up with the data expected by the specific Resource subclass.		 */		public function registerEmbeddedResource(path:String, type:Class, data:*):void		{			var identifier:String = createIdentifier(path, type);						if (_resources[identifier])			{				HLog.warn(toString() + " An embedded resource from file <" + path					+ "> has already been registered.");				return;			}						/* Set up the resource, but don't process it yet. */			try			{				var resource:Resource = new type();				resource.path = path;				resource.initialize(data);								/* These can be in the try since the catch will return. */				resource.incrementReferenceCount();				_resources[identifier] = resource;			}			catch(e:Error)			{				HLog.error(toString() + " Could not instantiate resource <" + path					+ "> due to error: " + e.message);				return;			}		}						/**		 * Provide a source for resources to the ResourceManager. Once added, the		 * ResourceManager will use this IResourceProvider to try to fulfill resource load		 * requests.		 * 		 * @param resourceProvider Provider to add.		 * @see IResourceProvider		 */		public function registerResourceProvider(provider:IResourceProvider):void		{			/* Check if resource provider is already registered */			for (var i:int = 0; i < _providers.length; i++)			{				if (_providers.indexOf(provider) >= 0)				{					return;				}			}						/* Add resource provider to list of known resource providers */			_providers.push(provider);		}						/**		 * Check if a resource is loaded and ready to go.		 * 		 * @param path Same as request to load()		 * @param type Same as request to load().		 * @return True if resource is loaded.		 */		public function isResourceLoaded(path:String, type:Class):Boolean		{			var identifier:String = createIdentifier(path, type);			if(!_resources[identifier])			{				return false;			}						var r:Resource = _resources[identifier];			return r.loaded;                		}						/**		 * Creates an identifier string under which a resource is stored.		 */		public static function createIdentifier(path:String, type:Class):String		{			return path.toLowerCase() + type;		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns the singleton instance of ResourceManager.		 */		public static function get instance():ResourceManager		{			if (_instance == null)			{				_singletonLock = true;				_instance = new ResourceManager();				_singletonLock = false;			}			return _instance;		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Properly marks a resource as failed-to-load.		 * @private		 */		protected function fail(resource:Resource,									failedHandler:Function,									message:String):void		{			if (!resource)			{				throw new NullReferenceException("Tried to fail a resource that is null.");			}						HLog.error(toString() + " " + message);						if (failedHandler != null)			{				setTimeout(failedHandler, 1, resource);			}		}	}}