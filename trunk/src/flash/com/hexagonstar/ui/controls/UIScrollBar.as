/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.ui.controls{	import com.hexagonstar.ui.core.UIComponent;	import com.hexagonstar.ui.core.InvalidationType;	import com.hexagonstar.ui.events.ScrollEvent;		import flash.events.Event;	import flash.events.TextEvent;	import flash.text.TextField;			/**	 * The UIScrollBar class includes all of the scroll bar functionality, but      * adds a <code>scrollTarget()</code> method so it can be attached	 * to a TextField component instance.	 *	 * <p><strong>Note:</strong> When you use ActionScript to update properties of 	 * the TextField component that affect the text layout, you must call the 	 * <code>update()</code> method on the UIScrollBar component instance to refresh its scroll 	 * properties. Examples of text layout properties that belong to the TextField 	 * component include <code>width</code>, <code>height</code>, and <code>wordWrap</code>.</p>	 * 	 * TODO Needs cleanup!	 */	public class UIScrollBar extends ScrollBar	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _scrollTarget:TextField;		protected var inEdit:Boolean = false;			protected var inScroll:Boolean = false;				private static var defaultStyles:Object = {};						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new UIScrollBar instance.		 */		public function UIScrollBar()		{			super();		}						/**		 * Forces the scroll bar to update its scroll properties immediately.  		 * This is necessary after text in the specified <code>scrollTarget</code> text field		 * is added using ActionScript, and the scroll bar needs to be refreshed.		 *		 * @see #scrollTarget		 */		public function update():void		{			inEdit = true;			updateScrollTargetProperties();			inEdit = false;		}						/**		 * @copy fl.controls.ScrollBar#setScrollProperties()		 *		 * @see ScrollBar#pageSize ScrollBar.pageSize		 * @see ScrollBar#minScrollPosition ScrollBar.minScrollPosition		 * @see ScrollBar#maxScrollPosition ScrollBar.maxScrollPosition		 * @see ScrollBar#pageScrollSize ScrollBar.pageScrollSize		 */		override public function setScrollProperties(pageSize:Number,minScrollPosition:Number,maxScrollPosition:Number,pageScrollSize:Number = 0):void		{			var maxScrollPos:Number = maxScrollPosition;			var minScrollPos:Number = (minScrollPosition < 0) ? 0 : minScrollPosition;						if (_scrollTarget != null) 			{								if (direction == ScrollBarDirection.HORIZONTAL) 				{					maxScrollPos = (maxScrollPosition > _scrollTarget.maxScrollH) ? _scrollTarget.maxScrollH : maxScrollPos;				} 				else 				{					maxScrollPos = (maxScrollPosition > _scrollTarget.maxScrollV) ? _scrollTarget.maxScrollV : maxScrollPos;				}			}			super.setScrollProperties(pageSize, minScrollPos, maxScrollPos, pageScrollSize);		}						/**		 * @private (protected)		 */		override public function setScrollPosition(scrollPosition:Number, fireEvent:Boolean = true):void		{			super.setScrollPosition(scrollPosition, fireEvent);			if (!_scrollTarget) 			{ 				inScroll = false; 				return; 			}			updateTargetScroll();		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				public static function get styleDefinition():Object		{ 			return UIComponent.mergeStyles(defaultStyles, ScrollBar.styleDefinition);		}						/**		 * @private		 */		override public function set minScrollPosition(minScrollPosition:Number):void		{			super.minScrollPosition = (minScrollPosition < 0) ? 0 : minScrollPosition;		}						/**		 * @private		 */		override public function set maxScrollPosition(maxScrollPosition:Number):void		{			var maxScrollPos:Number = maxScrollPosition;			if (_scrollTarget != null) 			{ 				if (direction == ScrollBarDirection.HORIZONTAL) 				{					maxScrollPos = (maxScrollPos > _scrollTarget.maxScrollH) ? _scrollTarget.maxScrollH : maxScrollPos;				} 				else 				{					maxScrollPos = (maxScrollPos > _scrollTarget.maxScrollV) ? _scrollTarget.maxScrollV : maxScrollPos;				}			}			super.maxScrollPosition = maxScrollPos;		}						/**		 * Registers a TextField component instance with the ScrollBar component instance.		 * @see #update()		 */		public function get scrollTarget():TextField		{			return _scrollTarget;		}				public function set scrollTarget(target:TextField):void		{			if (_scrollTarget != null) 			{				_scrollTarget.removeEventListener(Event.CHANGE, handleTargetChange, false);				_scrollTarget.removeEventListener(TextEvent.TEXT_INPUT, handleTargetChange, false);				_scrollTarget.removeEventListener(Event.SCROLL, handleTargetScroll, false);				removeEventListener(ScrollEvent.SCROLL, updateTargetScroll, false);			}			_scrollTarget = target;			if (_scrollTarget != null) 			{				_scrollTarget.addEventListener(Event.CHANGE, handleTargetChange, false, 0, true);				_scrollTarget.addEventListener(TextEvent.TEXT_INPUT, handleTargetChange, false, 0, true);				_scrollTarget.addEventListener(Event.SCROLL, handleTargetScroll, false, 0, true);				addEventListener(ScrollEvent.SCROLL, updateTargetScroll, false, 0, true);			}				invalidate(InvalidationType.DATA);		}						/**		 * @private (internal)		 * @internal For specifying in inspectable, and setting dropTarget		 */		public function get scrollTargetName():String		{			return _scrollTarget.name;		}				public function set scrollTargetName(target:String):void		{			try 			{				scrollTarget = parent.getChildByName(target) as TextField;			} catch (error:Error) 			{				throw new Error("ScrollTarget not found, or is not a TextField");			}		}						/**		 * @copy fl.controls.ScrollBar#direction		 * @see ScrollBarDirection		 */		override public function get direction():String		{ 			return super.direction;		}				override public function set direction(dir:String):void		{			super.direction = dir;			updateScrollTargetProperties();		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				override protected function draw():void		{			if (isInvalid(InvalidationType.DATA)) 			{				updateScrollTargetProperties();			}			super.draw();		}						protected function updateScrollTargetProperties():void		{			if (_scrollTarget == null) 			{				setScrollProperties(pageSize, minScrollPosition, maxScrollPosition, pageScrollSize);				scrollPosition = 0;			} 			else 			{				var horizontal:Boolean = (direction == ScrollBarDirection.HORIZONTAL);				var pageSize:Number = horizontal ? _scrollTarget.width : 10;				setScrollProperties(pageSize, (horizontal ? 0 : 1), horizontal ? _scrollTarget.maxScrollH : _scrollTarget.maxScrollV, pageScrollSize);				scrollPosition = horizontal ? _scrollTarget.scrollH : _scrollTarget.scrollV;			}		}						// event default is null, so when user calls setScrollPosition, the text is updated, and we don't pass an event		/**		 * @private (protected)		 */		protected function updateTargetScroll(event:ScrollEvent = null):void		{			if (inEdit) 			{ 				return; 			} // Update came from the user input. Ignore.			if (direction == ScrollBarDirection.HORIZONTAL) 			{				_scrollTarget.scrollH = scrollPosition;			} 			else 			{				_scrollTarget.scrollV = scrollPosition;			}		}						protected function handleTargetChange(event:Event):void		{			inEdit = true;			setScrollPosition((direction == ScrollBarDirection.HORIZONTAL) ? _scrollTarget.scrollH : _scrollTarget.scrollV, true);			updateScrollTargetProperties();			inEdit = false;		}						protected function handleTargetScroll(event:Event):void		{			if (inDrag) 			{ 				return; 			}			if (!enabled) 			{ 				return; 			}					inEdit = true;			updateScrollTargetProperties(); // This needs to be done first! 			scrollPosition = (direction == ScrollBarDirection.HORIZONTAL) ? _scrollTarget.scrollH : _scrollTarget.scrollV;			inEdit = false;		}	}}