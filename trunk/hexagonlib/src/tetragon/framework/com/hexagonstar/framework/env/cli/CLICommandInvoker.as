package com.hexagonstar.framework.env.cli{	import com.hexagonstar.data.types.Byte;	import com.hexagonstar.data.types.Time;	import com.hexagonstar.display.text.ColumnText;	import com.hexagonstar.framework.view.console.Console;	import flash.system.Capabilities;	import flash.system.System;	import flash.utils.getTimer;		/**	 * Handles the execution of commands entered into the Console CLI. This class	 * provides a default set of Console commands but can be extended to implement	 * application-specific commands or functions. The extending handler class must	 * then implement the ICLICommandInvoker marker interface.	 */	public class CLICommandInvoker implements ICLICommandInvoker	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _console:Console;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new CLICommandInvoker instance.		 */		public function CLICommandInvoker()		{			_console = Console.instance;		}				/**		 * consoleMessage		 */		public function consoleMessage(msg:String, level:int = 2):void		{			_console.log(msg, level);		}						/**		 * consoleClear		 */		public function consoleClear():void		{			_console.clear();		}						/**		 * consoleHide		 */		public function consoleHide():void		{			_console.clearInput();			_console.toggle();		}						/**		 * consoleHelp		 */		public function consoleHelp(commands:Vector.<CLICommand>):void		{			var s:String = "\nConsole Commands:\n";			var t:ColumnText = new ColumnText(2);			for each (var c:CLICommand in commands)			{				t.add(["\t" + c.command, "(" + c.help + ")"]);			}			_console.log(s + t.toString());		}						/**		 * consoleMem		 */		public function consoleMem():void		{			_console.log("Memory used: " + new Byte(System.totalMemory).toString());		}						/**		 * consoleTime		 */		public function consoleTime():void		{			_console.log("Running since " + new Time(getTimer()).toString());		}						/**		 * consoleBufferSize		 */		public function consoleBufferSize():void		{			_console.log("Current buffer size: " + _console.bufferSize + "/"				+ _console.maxBufferSize + " bytes");		}						/**		 * consoleGC		 */		public function consoleGC():void		{			var a:String = new Byte(System.totalMemory).toString();			System.gc();			var b:String = new Byte(System.totalMemory).toString();			_console.log("Garbage collection executed, mem before: " + a + ", mem after: " + b);		}						/**		 * consoleFull		 */		public function consoleFull():void		{			_console.toggleSize();		}						/**		 * consoleRuntime		 */		public function consoleRuntime():void		{			var d:String = Capabilities.isDebugger.toString();			var t:String = Capabilities.playerType;			var v:String = Capabilities.version;			var a:Array = v.split(" ");			var p:String = a.shift();			a = String(a[0]).split(",");			v = a[0] + "." + a[1] + "." + a[2] + " (" + a[3] + ")";			_console.log("runtime version: " + v + ", type: " + t + ", platform: " + p				+ ", debugger: " + d);		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////	}}