/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.util{	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.PixelSnapping;	import flash.geom.Matrix;		/**	 * BitmapUtil Class	 */	public class BitmapUtil	{		////////////////////////////////////////////////////////////////////////////////////////		// Constants                                                                          //		////////////////////////////////////////////////////////////////////////////////////////						////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Produces a matrix which is scaled and translated according to the		 * differences between the specified bitmap's width/height and the		 * specified target width/height. This matrix can then be used to		 * resize bitmaps while keeping their correct proportions when shrinking		 * or enlarging the bitmap.		 * Additionally centerV and centerH can be specified to determine whether		 * the matrix should be translated so that the resized bitmap stays		 * centered horizontally and/or vertically.		 * 		 * @param bitmap The bitmap of which to create a resize matrix.		 * @param targetWidth The target width of the resize.		 * @param targetHeight The target height of the resize.		 * @param centerH true if the bitmap is being centered horizontally.		 * @param centerV true if the bitmap is being centered vertically.		 * @return the generated resize matrix.		 */		public static function createResizeMatrix(bitmap:Bitmap,													   targetWidth:int,													   targetHeight:int,													   centerH:Boolean = true,													   centerV:Boolean = true):Matrix		{			var x:int = 0;			var y:int = 0;			var w:int = bitmap.width;			var h:int = bitmap.height;			var ratio:Number = h / w;			var resizeHeight:Boolean = true;			var m:Matrix = new Matrix();						/* Check if width is different and resize accordingly */			if (w != targetWidth)			{				w = targetWidth;				h = Math.round(w * ratio);				if (h < targetHeight) resizeHeight = false;			}						/* Check if height should be resized. If the height has become smaller			 * due to the width-based resize, we don't want to resize here otherwise			 * the size would go back to it's original width */			if (resizeHeight)			{				if (h != targetHeight)				{					h = targetHeight;					w = Math.round(h / ratio);				}			}						/* Center horizontally if width is different than target size */			if (w != targetWidth)			{				x = (targetWidth / 2) - (w / 2);			}						/* Center vertically if height is different than target size */			if (h != targetHeight)			{				y = (targetHeight / 2) - (h / 2);			}						m.scale(w / bitmap.width, h / bitmap.height);			m.translate(x, y);						return m;		}						/**		 * Resizes the specified bitmap proportionally.		 * 		 * @param bitmap The bitmap which should be resized.		 * @param targetWidth The target width of the resize.		 * @param targetHeight The target height of the resize.		 * @param centerH true if the bitmap is being centered horizontally.		 * @param centerV true if the bitmap is being centered vertically.		 * @param smoothing true if resized bitmap is being smoothed.		 * @return A new Bitmap with the resized image.		 */		public static function resizeBitmap(bitmap:Bitmap,											  	targetWidth:int,											  	targetHeight:int,											  	centerH:Boolean = true,											  	centerV:Boolean = true,											  	smoothing:Boolean = true):Bitmap		{			var m:Matrix = createResizeMatrix(bitmap, targetWidth, targetHeight,				centerH, centerV);			var b:BitmapData = new BitmapData(targetWidth, targetHeight, false, 0x000000);			b.draw(bitmap, m, null, null, null, smoothing);			return new Bitmap(b, PixelSnapping.AUTO, true);		}	}}