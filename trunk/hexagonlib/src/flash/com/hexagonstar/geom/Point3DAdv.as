/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.geom{	import com.hexagonstar.core.BasicClass;	import com.hexagonstar.data.types.Percent;	import com.hexagonstar.util.NumberUtil;			/**	 * Represents a 3D point that stores it's location in a three-dimensional	 * coordinate system, where x represents the horizontal axis, y represents	 * the vertical axis, z represents the axis that is vertically perpendicular	 * to the x/y axis or depth.	 */	public class Point3DAdv extends BasicClass	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				public var x:Number;		public var y:Number;		public var z:Number;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new Point3DAdv.		 * 		 * @param x The horizontal coordinate of the point.		 * @param y The vertical coordinate of the point.		 * @param z The depth coordinate of the point.		 */		public function Point3DAdv(x:Number = 0, y:Number = 0, z:Number = 0)		{			this.x = x;			this.y = y;			this.z = z;		}						/**		 * Provides a quick way to set the properties of an existing Point3DAdv.		 * 		 * @param newX The new horizontal coordinate of the point.		 * @param newY The new vertical coordinate of the point.		 * @param newZ The new depth coordinate of the point.		 */		public function set(newX:Number = 0, newY:Number = 0, newZ:Number = 0):void		{			x = newX;			y = newY;			z = newZ;		}						/**		 * Adds the coordinates of another Point3D to the coordinates of this		 * point to create a new Point3D.		 * 		 * @param point The point to be added.		 * @return The new point.		 */		public function add(point:Point3DAdv):Point3DAdv		{			return new Point3DAdv(x + point.x, y + point.y, z + point.z);		}						/**		 * Subtracts the coordinates of another Point3D from the coordinates		 * of this point to create a new Point3D.		 * 		 * @param point The point to be subtracted.		 * @return The new point.		 */		public function subtract(point:Point3DAdv):Point3DAdv		{			return new Point3DAdv(x - point.x, y - point.y, z - point.z);		}						/**		 * Offsets the Point3D object by the specified amount.		 * 		 * @param xOffset The amount by which to offset the horizontal coordinate.		 * @param yOffset The amount by which to offset the vertical coordinate.		 * @param zOffset The amount by which to offset the depth coordinate.		 */		public function offset(xOffset:Number, yOffset:Number, zOffset:Number):void		{			x += xOffset;			y += yOffset;			z += zOffset;		}						/**		 * Determines if the Point3D specified in the point parameter is equal		 * to this Point3D object.		 * 		 * @param point A Point3D object.		 * @return Returns {@code true} if shape's location is identical; otherwise {@code false}.		 */		public function equals(point:Point3DAdv):Boolean		{			return x == point.x && y == point.y && z == point.z;		}						/**		 * Creates a clone of the Point3D object.		 * 		 * @return A new Point3D with the same values as this point.		 */		public function clone():Point3DAdv		{			return new Point3DAdv(x, y, z);		}						/**		 * Returns a String Representation of Point3D.		 * 		 * @return A String Representation of Point3D.		 */		override public function toString(...args):String		{			return super.toString("x=" + x, "y=" + y, "z=" + z);		}						/**		 * Determines the distance between the first and second points in 3D space.		 * 		 * @param p1 The first Point3D.		 * @param p2 The second Point3D.		 * @return Distance between the two points.		 */		public static function distance(p1:Point3DAdv, p2:Point3DAdv):Number		{			var x:Number = p2.x - p1.x;			var y:Number = p2.y - p1.y;			var z:Number = p2.z - p1.z;			return Math.sqrt(x * x + y * y + z * z);		}						/**		 * Determines a point between two specified points.		 * 		 * @param p1 The first Point3D.		 * @param p2 The second Point3D.		 * @param amount The level of interpolation between the two points.		 *         If 0%, p1 is returned; if 100%, p2 is returned.		 * @return The new, interpolated point.		 */		public static function interpolate(p1:Point3DAdv, p2:Point3DAdv, amount:Percent):Point3DAdv		{			var x:Number = NumberUtil.interpolate(amount, p1.x, p2.x);			var y:Number = NumberUtil.interpolate(amount, p1.y, p2.y);			var z:Number = NumberUtil.interpolate(amount, p1.z, p2.z);			return new Point3DAdv(x, y, z);		}						/**		 * Returns the Dot Product of two specified points.		 * 		 * @return the Dot Product of two specified points.		 */		public static function dot(p1:Point3DAdv, p2:Point3DAdv):Number		{			return (p1.x * p2.x + p1.y * p2.y + p2.z * p1.z);		}						/**		 * Returns a new Point3D as the Cross Product of two specified points. If a		 * Point3D is specified as the target parameter, the result will be set to that		 * point instead of creating a new Point3D object.		 * 		 * @param p1 The first Point3D.		 * @param p2 The second Point3D.		 * @param target an optional Point3D to use for the result.		 * @return a Point3D object wil the cross product result.		 */		public static function cross(p1:Point3DAdv, p2:Point3DAdv, target:Point3DAdv = null):Point3DAdv		{			if (!target) target = new Point3DAdv();			target.set			(				(p2.y * p1.z) - (p2.z * p1.y),				(p2.z * p1.x) - (p2.x * p1.z),				(p2.x * p1.y) - (p2.y * p1.x)			);			return target;		}	}}