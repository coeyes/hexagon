/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.data.structures.grids{	import com.hexagonstar.core.BasicClass;	import com.hexagonstar.data.structures.IIterator;	import com.hexagonstar.env.exception.DataStructureException;	import com.hexagonstar.env.exception.IllegalArgumentException;			/**	 * Grid2D Class	 */	public class Grid2D extends BasicClass	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				protected var _grid:Vector.<Vector.<int>>;		protected var _width:int;		protected var _height:int;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Constructs a new Grid2D instance. The grid will have the size of		 * the specified width and height arguments and every cell is set to the		 * value specified with the fillValue argument. Optionally a two dimensional		 * source array can be specified whose values are used to populate the grid.		 * The first three arguments are ignored if a source array was provided.		 * 		 * @param width A value that determines how many cells wide the grid		 *        should be.		 * @param height A value that determines how many cells high the grid		 *        should be.		 * @param fillValue A value that is used to fill all cells in the new grid.		 * @param source An array that is used as the source to populate the grid.		 *        The width and height parameters are ignored and the dimensions		 *        of the specified source array are used instead.		 */		public function Grid2D(width:int, height:int, fillValue:int = 0,			source:Vector.<Vector.<int>> = null)		{			if (!source)			{				_width = width;				_height = height;				clear(fillValue);			}			else			{				fromVector(source);			}		}						////////////////////////////////////////////////////////////////////////////////////////		// Query Operations                                                                   //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns the size of the grid, or in other words how many cells		 * the grid has.		 * 		 * @return The cell amount of the grid.		 */		public function get size():int		{			return _height * _width;		}						/**		 * Checks if the specified value exists in the Grid.		 * 		 * @return true if the Grid contains the specified value or false if not.		 */		public function contains(value:int):Boolean		{			// TODO			return false;		}						/**		 * Returns the content of the grid cell at the specified x and y		 * coordinate.		 * 		 * @param x The x coordinate in the grid.		 * @param y The y coordinate in the grid.		 * @return The content of the grid cell at the specified x and y		 *         coordinate.		 */		public function getCell(x:int, y:int):*		{			return _grid[y][x];		}						/**		 * Returns the width of the grid measured in cells.		 * @return The width of the grid measured in cells.		 */		public function get width():int		{			return _width;		}						/**		 * Returns the height of the grid measured in cells.		 * @return The height of the grid measured in cells.		 */		public function get height():int		{			return _height;		}						/**		 * Returns an array representation of the grid.		 * @return An array representation of the grid.		 */		public function toArray():Array		{			// TODO			return null;			//return _grid.concat();		}						/**		 * Returns a clone of the Grid. The clone will be safe for use in		 * that it doesn't maintain any reference to the original Grid.		 * 		 * @return A clone of the Grid.		 */		public function clone():*		{			return new Grid2D(0, 0, 0, _grid);		}						/**		 * Returns an iterator for iterating over the cells of the grid.		 *		 * @return An <code>Iterator</code> to iterate over the cells of		 *         the grid.		 */		public function iterator():IIterator		{			// TODO Grid Iterator to be implemented!			return null;		}						/**		 * Returns a String Representation of the Collection Type.		 * 		 * @return A String Representation of the Collection Type.		 */		override public function toString(...args):String		{			return super.toString("size=" + size);		}						/**		 * Returns a String Representation of the Grid that can be used		 * for debugging purposes.		 * 		 * @return a String representation of the Grid.		 */		public function dump():String		{			var s:String = "\n" + toString();			var r:String;						for (var y:int = 0; y < _height; y++)			{				r = "\n";				var s1:String = "";				for (var x:int = 0; x < _width; x++)				{					r += _grid[y][x] + ", ";				}				s += r;			}			return s;		}						////////////////////////////////////////////////////////////////////////////////////////		// Modification Operations                                                            //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Stores the specified value into the grid cell that is at the		 * specified x and y coordinates and returns the value that was at		 * this coordinate before.		 * 		 * @param x The x coordinate in the grid.		 * @param y The y coordinate in the grid.		 * @param value That value that should be placed in the grid cell.		 * @return The value that was at the specified grid cell before.		 */		public function setCell(x:int, y:int, value:int):int		{			var result:int = _grid[y][x];			_grid[y][x] = value;			return result;		}						/**		 * Clears the cell that is at the specified x and y coordinate.		 * This sets the cell to the value 0.		 * 		 * @param x The x coordinate in the grid.		 * @param y The y coordinate in the grid.		 * @return The value that was at the specified grid cell before.		 */		public function clearCell(x:int, y:int):int		{			return setCell(x, y, 0);		}						/**		 * Adds the specified value to the value that is stored in the grid		 * cell at the specified x and y coordinates, if any and returns the		 * old value of the cell.		 * 		 * @param x The x coordinate in the grid.		 * @param y The y coordinate in the grid.		 * @param value The value to add to the specified coordinate.		 * @return The value that was at the specified grid cell before.		 */		public function addToCell(x:int, y:int, value:int):int		{			var oldValue:int = _grid[y][x];			_grid[y][x] = oldValue + value;			return oldValue;		}						/**		 * Multiplies the specified value to the value that is stored in the		 * grid cell at the specified x and y coordinates and returns the		 * old value of the cell.		 * 		 * @param x The x coordinate in the grid.		 * @param y The y coordinate in the grid.		 * @param value The value to multiply to the specified coordinate.		 * @return The value that was at the specified grid cell before.		 */		public function multiplyToCell(x:int, y:int, value:int):int		{			var oldValue:int = _grid[y][x];			_grid[y][x] = oldValue * value;			return oldValue;		}						////////////////////////////////////////////////////////////////////////////////////////		// Bulk Operations                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Fills the rectangular region of the grid defined by the specified		 * x1, y1 and x2, y2 coordinates with the specified value.		 * 		 * @param x The start x coordinate of the fill area.		 * @param y The start y coordinate of the fill area.		 * @param x The end x coordinate of the fill area.		 * @param y The end y coordinate of the fill area.		 * @param value The fill value.		 * 		 * @throws com.hexagonstar.env.exception.IllegalArgumentException if		 *         the specified start coordinates are outside the existing grid		 *         dimensions.		 * @throws com.hexagonstar.env.exception.IllegalArgumentException if		 *         the end coordinates are smaller than the start coordinates.		 */		public function fill(x1:int, y1:int, x2:int, y2:int, value:int):void		{			if (x1 >= _width || x2 >= _width || y1 >= _height || y2 >= _height)			{				throw new IllegalArgumentException("fill coordinates are out of bound:"					+ " x1[" + x1 + "]  y1[" + y1 + "]  x2[" + x2 + "]  y2[" + y2 + "]");			}			else			{				if (x2 < x1 || y2 < y2)				{					throw new IllegalArgumentException("Cannot fill with end coords being"						+ " smaller than start coords: x1[" + x1 + "]  y1[" + y1 + "]  x2["						+ x2 + "]  y2[" + y2 + "]");				}				else				{					for (var y:int = y1; y <= y2; y++)					{						for (var x:int = x1; x <= x2; x++)						{							_grid[y][x] = value;						}					}				}			}		}						/**		 * Resizes the grid to the dimensions of the specified newWidth and		 * newHeight. If the resulting grid dimension is larger than the old		 * one, new cells are filled with the value specified in the fillValue		 * argument.		 * 		 * @param newWidth The new width (in cells) of the grid.		 * @param newHeight The new height (in cells) of the grid.		 * @param fillValue The value used to fill new cells if the new grid		 *        size is larger than the old one.		 */		public function resize(newWidth:int, newHeight:int, fillValue:int = 0):void		{			var oldGrid:Vector.<Vector.<int>> = _grid.concat();			_width = newWidth;			_height = newHeight;			clear(fillValue);			pasteFromVector(oldGrid, 0, 0);		}						/**		 * Copies a rectangular region from the grid defined by the specified		 * x1, y1 and x2, y2 coordinates and returns this region as a new grid		 * instance. If all coordinates are <code>0</code> the whole grid is		 * copied and returned.		 * 		 * @param x The start x coordinate of the region to copy.		 * @param y The start y coordinate of the region to copy.		 * @param x The end x coordinate of the region to copy.		 * @param y The end y coordinate of the region to copy.		 */		public function copy(x1:int = 0, y1:int = 0, x2:int = 0, y2:int = 0):Grid2D		{			var result:Grid2D;						/* If all arguments are zero, copy the whole grid */			if ((x1 + x2 + y1 + y2) == 0)			{				result = clone();			}			else			{				/* Check if either x coords or y coords are zero */				var newX:int;				var newY:int;				var newWidth:int = (x1 == 0 && x2 == 0) ? _width : (x2 - x1);				var newHeight:int = (y1 == 0 && y2 == 0) ? _height : (y2 - y1);								result = new Grid2D(newWidth, newHeight);				newWidth = newWidth + x1;				newHeight = newHeight + y1;								for (var y:int = y1; y < newHeight; y++)				{					newY = y - y1;					for (var x:int = x1; x < newWidth; x++)					{						newX = x - x1;						result.setCell(newX, newY, _grid[y][x]);					}				}			}			return result;		}						/**		 * Pastes the specified grid onto this grid starting at the specified		 * x1 and y1 coordinate. If the pasted region's dimension exceeds the		 * current size of the grid, the exceeding region is cropped.		 * 		 * @param grid The grid to paste onto this grid.		 * @param x1 The x coordinate at where to paste the grid.		 * @param y1 The y coordinate at where to paste the grid.		 * 		 * @throws com.hexagonstar.env.exception.IllegalArgumentException if		 *         the specified coordinates are outside the existing grid		 *         dimensions.		 */		public function paste(grid:Grid2D, x:int = 0, y:int = 0):void		{			if (x >= _width || y >= _height)			{				throw new IllegalArgumentException("Start coordinates for paste"					+ "operation are out of bound: x[" + x + "]  y[" + y + "]");			}			else			{				var y2:int = (grid.height - 1) + y;				var x2:int = (grid.width - 1) + x;								/* If the end coords are exceeding the grid's boundary, crop them */				if (y2 > _height - 1) y2 = _height - 1;				if (x2 > _width - 1) x2 = _width - 1;								for (var i:int = y; i <= y2; i++)				{					for (var j:int = x; j <= x2; j++)					{						_grid[i][j] = grid.getCell(j - x, i - y);					}				}			}		}						/**		 * Pastes the specified 2D array onto the grid starting at the		 * specified x1 and y1 coordinate. If the pasted region's dimension		 * exceeds the current size of the grid, the exceeding region is		 * cropped.		 * 		 * @param array The 2D array to paste onto the grid.		 * @param x1 The x coordinate at where to paste the grid.		 * @param y1 The y coordinate at where to paste the grid.		 * 		 * @throws com.hexagonstar.env.exception.IllegalArgumentException if		 *         the specified coordinates are outside the existing grid		 *         dimensions.		 */		public function pasteFromVector(vector:Vector.<Vector.<int>>,			x:int = 0, y:int = 0):void		{			if (x >= _width || y >= _height)			{				throw new IllegalArgumentException("Start coordinates for paste"				+ " operation are out of bound: x[" + x + "]  y[" + y + "]");			}			else			{				var y2:int = (vector.length - 1) + y;				var x2:int = (vector[0].length - 1) + x;								/* If the end coords are exceeding the grid's boundary, crop them */				if (y2 > _height - 1) y2 = _height - 1;				if (x2 > _width - 1) x2 = _width - 1;								for (var i:int = y; i <= y2; i++)				{					for (var j:int = x; j <= x2; j++)					{						_grid[i][j] = vector[i - y][j - x];					}				}			}		}						/**		 * Uses the values of the specified 2D array to populate the grid.		 * 		 * @param source The array from which the values to use to		 *        populate the grid.		 */		public function fromArray(source:Array):void		{			if (source.length == 0 || source[0].length == 0)			{				throw new DataStructureException("Tried to use an empty or non-2D"					+ " array as a source!");			}			else			{				// TODO for Vector!				//_grid = source.concat();				//_height = _grid.length;				//_width = _grid[0].length;			}		}						/**		 * Uses the values of the specified 2D vector to populate the grid.		 * @param source The vector from which the values to use to populate the grid.		 */		public function fromVector(source:Vector.<Vector.<int>>):void		{			if (source.length == 0 || source[0].length == 0)			{				throw new DataStructureException("Tried to use an empty or non-2D"					+ " vector as a source!");			}			else			{				_grid = source.concat();				_height = _grid.length;				_width = _grid[0].length;			}		}						/**		 * Clears the grid with the specified value as the initial value for		 * every grid cell.		 * 		 * @param fillValue The value to fill the grid with.		 */		public function clear(fillValue:int = 0):void		{			_grid = new Vector.<Vector.<int>>(_height);			var row:Vector.<int>;						for (var y:int = 0; y < _height; y++)			{				row = new Vector.<int>(_width);				for (var x:int = 0; x < _width; x++)				{					row[x] = fillValue;				}				_grid[y] = row;			}		}	}}