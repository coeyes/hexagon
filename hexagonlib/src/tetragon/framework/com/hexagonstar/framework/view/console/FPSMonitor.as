/* * tetragon - Application framework for Flash, Flash/AIR, Flex & Flex/AIR. *  * Licensed under the MIT License * Copyright (c) 2008-2009 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.framework.view.console{	import com.hexagonstar.display.StageReference;	import com.hexagonstar.display.filters.TextOutlineFilter;	import com.hexagonstar.display.ui.controls.Label;	import com.hexagonstar.util.FontUtil;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.GlowFilter;	import flash.system.System;	import flash.text.TextFormat;	import flash.text.TextFormatAlign;	import flash.utils.getTimer;		/**	 * @author Sascha Balkau	 * @version 1.0.0	 */	public class FPSMonitor extends Sprite	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		protected static var _instance:FPSMonitor;		/** @private */		protected static var _singletonLock:Boolean = false;				/** @private */		protected var _fpsLabel:Label;		/** @private */		protected var _memLabel:Label;		/** @private */		protected var _fps:int;		/** @private */		protected var _defaultFPS:int;		/** @private */		protected var _frameDelay:int;		/** @private */		protected var _frameDelayMax:int;		/** @private */		protected var _time:int;		/** @private */		protected var _prev:int;		/** @private */		protected var _pollInterval:Number = 1.0;		/** @private */		protected var _isRunning:Boolean;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new instance of the class.		 */		public function FPSMonitor()		{			if (!_singletonLock)			{				throw new Error("Tried to instantiate FPSMonitor through it's constructor."					+ " Use FPSMonitor.instance instead!");			}						setup();		}						/**		 * Starts the FPS Monitor.		 */		public function start():void		{			if (!_isRunning)			{				_isRunning = true;				StageReference.stage.addEventListener(Event.ENTER_FRAME, onEnterFrame);				visible = true;			}		}						/**		 * Stops the FPS Monitor.		 */		public function stop():void		{			if (_isRunning)			{				visible = false;				StageReference.stage.removeEventListener(Event.ENTER_FRAME, onEnterFrame);				reset();			}		}						/**		 * Resets the FPSMeter to it's default state.		 */		public function reset():void		{			_fps = 0;			_defaultFPS = StageReference.stage.frameRate;			_frameDelay = 0;			pollInterval = _pollInterval;			_time = 0;			_prev = 0;			_isRunning = false;		}						/**		 * toggle		 */		public function toggle():void		{			if (_isRunning) stop();			else start();		}						/**		 * Disposes FPSMonitor.		 */		public function dispose():void		{			stop();			removeEventListeners();		}						////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns the Singleton instance of FPSMonitor.		 */		public static function get instance():FPSMonitor		{			if (_instance == null)			{				_singletonLock = true;				_instance = new FPSMonitor();				_singletonLock = false;			}			return _instance;		}						/**		 * The poll interval of the fps monitor in seconds.		 */		public function get pollInterval():Number		{			return _pollInterval;		}		public function set pollInterval(v:Number):void		{			_pollInterval = v;			_frameDelayMax = _defaultFPS * _pollInterval;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * @private		 */		protected function onEnterFrame(e:Event):void		{			_time = getTimer();			_frameDelay++;						if (_frameDelay >= _frameDelayMax)			{				_frameDelay = 0;				_fps = int((1000 * _frameDelayMax) / (_time - _prev));				if (_fps > _defaultFPS) _fps = _defaultFPS;				_prev = _time;				_fpsLabel.text = _fps + "/" + _defaultFPS;				_memLabel.text = formatBytes(System.totalMemory);			}		}						protected function onStageResize(e:Event):void		{			x = StageReference.stage.stageWidth - width - 12;		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * setup		 * @private		 */		protected function setup():void		{			visible = false;			createChildren();			addEventListeners();			onStageResize(null);			reset();		}						/**		 * createChildren		 * @private		 */		protected function createChildren():void		{			var font:String;			for each (var s:String in Console.CONSOLE_FONTS)			{				if (FontUtil.isFontAvailable(s, true))				{					font = s;					break;				}			}			if (!font)			{				font = "mono";			}						var format1:TextFormat = new TextFormat();			format1.font = font;			format1.size = 20;			format1.color = 0xFFFFFF;			format1.bold = true;			format1.align = TextFormatAlign.RIGHT;						_fpsLabel = new Label(90, 26);			_fpsLabel.setStyle("embedFonts", false);			_fpsLabel.setStyle("textFormat", format1);			_fpsLabel.drawNow();			addChild(_fpsLabel);						var format2:TextFormat = new TextFormat();			format2.font = font;			format2.size = 11;			format2.color = 0xFFFFFF;			format2.bold = true;			format2.align = TextFormatAlign.RIGHT;						_memLabel = new Label(90, 16);			_memLabel.setStyle("embedFonts", false);			_memLabel.setStyle("textFormat", format2);			_memLabel.y = _fpsLabel.height - 4;			_memLabel.drawNow();			addChild(_memLabel);						var f:GlowFilter = TextOutlineFilter.create(4);			filters = [f];			y = 10;		}						/**		 * addEventListeners		 * @private		 */		protected function addEventListeners():void		{			StageReference.stage.addEventListener(Event.RESIZE, onStageResize);		}						/**		 * removeEventListeners		 * @private		 */		protected function removeEventListeners():void		{			StageReference.stage.removeEventListener(Event.RESIZE, onStageResize);		}						/**		 * formatBytes		 * @private		 */		protected function formatBytes(bytes:int):String		{			var r:String;			if (bytes < 0xA00000)			{				r = (Number((bytes / 0x100000)).toFixed(2) + "mb");			}			 else 			{				if (bytes < 104857600)				{					r = (Number((bytes / 0x100000)).toFixed(1) + "mb");				}				else 				{					r = ((bytes >> 20) + "mb");				}			}			return r;		}	}}