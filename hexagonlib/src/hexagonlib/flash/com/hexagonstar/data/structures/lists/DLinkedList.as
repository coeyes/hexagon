/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.data.structures.lists{	import com.hexagonstar.data.structures.ICollection;	import com.hexagonstar.data.structures.IIterator;	import com.hexagonstar.display.text.ColumnText;		/**	 * A doubly linked list, i.e. a list in which every element not only keeps a link to	 * it's next but also to it's previous element, hence making it possible to also	 * traverse backward along the list.	 * 	 * @author Sascha Balkau	 * @version 1.0.0	 */	public class DLinkedList extends AbstractList implements IList	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		protected var _first:Node;		/** @private */		protected var _last:Node;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new DLinkedList instance.		 * 		 * @param elements Optional elements which are added to the list.		 */		public function DLinkedList(...elements)		{			_size = 0;			_first = _last = null;						if (elements.length > 0)			{				append.apply(this, elements);			}		}						////////////////////////////////////////////////////////////////////////////////////////		// Query Operations                                                                   //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Returns the element from the list that is at the specified index.		 * 		 * @param index The index in the list from where the element should be returned.		 * @return The element that is at the specified index.		 * @throws com.hexagonstar.exception.IndexOutOfBoundsException if the specified		 *             index is not in range, i.e. it is greater than the list's size or		 *             lower than 0.		 */		override public function getElementAt(index:int):*		{			if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else			{				var current:Node = _first;				var i:int = 0;				while (i < index)				{					current = current.next;					i++;				}				return current.data;			}		}						/**		 * Checks if the list contains the specified element. If the element exists in the		 * list, true is returned, otherwise false.		 * 		 * @param element The element whose presence in the list is to be tested.		 * @return true if the list contains the specified element, otherwise false.		 */		override public function contains(element:*):Boolean		{			if (_size < 1) return false;						var node:Node = _first;			while (node)			{				if (node.data === element) return true;				node = node.next;			}			return false;		}						/**		 * Checks if the list is equal to the specified list.		 * 		 * @param list The list to be checked against this list.		 * @return true if both lists are equal, false if not.		 */		public function equals(list:ICollection):Boolean		{			if (list is DLinkedList)			{				var l:DLinkedList = DLinkedList(list);				var i:int = l.size;				if (i != _size) return false;								while (i--)				{					if (l.getElementAt(i) != getElementAt(i))					{						return false;					}				}								return true;			}						return false;		}						/**		 * Returns an iterator to iterate over the list's elements.		 * 		 * @return an iterator to iterate over the list's elements.		 */		public function iterator():IIterator		{			return new ListIterator(this);		}						/**		 * Returns the index of the specified element in the list. If the specified element		 * was not found in the list -1 is returned.		 * 		 * @param element The element from which to return the index.		 * @return The index value of the specified element or -1 if the element was not		 *         found in the list.		 */		public function indexOf(element:*):int		{			var current:Node = _first;			var i:int = 0;						while (i < _size)			{				if (current.data === element) return i;				current = current.next;				i++;			}			return -1;		}						/**		 * Returns a String that contains the list elements joined together with the		 * specified separator string.		 * 		 * @param separator A string with that the joined elements are separated.		 * @return A string that contains the joined list elements or an empty string if the		 *         list is empty.		 */		public function join(separator:String = ","):String		{			if (_size < 1)			{				return "";			}						var s:String = "";			var node:Node = _first;			var i:int = 0;						while (node)			{				s += "" + node.data;				if (i < _size - 1)				{					s += separator;				}				node = node.next;				i++;			}			return s;		}						/**		 * Returns a clone of the list. The clone will be safe for use in that it doesn't		 * maintain any references to the original list.		 * 		 * @return A clone of the list.		 */		public function clone():*		{			var list:DLinkedList = new DLinkedList();			list.addAll(this);			return list;		}						/**		 * Returns an array that contains all of the elements that are currently in the		 * list. The returned array will be safe in that no references to it are maintained		 * by the list.		 * 		 * @return An array containing all of the elements of the list.		 */		public function toArray():Array		{			var a:Array = [];			var node:Node = _first;						while (node)			{				a.push(node.data);				node = node.next;			}			return a;		}						/**		 * Returns a formatted string representation of the list contents that can be used		 * for debugging purposes.		 * 		 * @return A formatted string representation of the list contents.		 */		public function dump():String		{			var s:String = toString() + "\n";			var t:ColumnText = new ColumnText(3, "  ");			var node:Node = _first;			var i:int = 0;						while (node)			{				t.add([(i < 10 ? " " : "") + "[" + i + ": " + node.data,						"P:" + (node.prev ? "[" + node.prev.data + "]" : "NULL"),						"N:" + (node.next ? "[" + node.next.data + "]" : "NULL") + "]"]);				node = node.next;				i++;			}						return s + "\n" + t;		}						////////////////////////////////////////////////////////////////////////////////////////		// Modification Operations                                                            //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Adds the specified element to the end of the list. This does the same like		 * calling append() with only one parameter. It is recommended to use the append()		 * method instead. This methods exists here merely for the purpose to follow the		 * collection interface.		 * 		 * @param element The element to add to the list.		 * @return true if the element was added successfully.		 */		public function add(element:*):Boolean		{			return append(element);		}						/**		 * Appends all specified elements to the end of the list.		 * 		 * @param elements The element(s) to append to the List.		 * @return true if the elements were appended successfully.		 */		override public function append(...elements):Boolean		{			var l:int = elements.length;			if (l < 1) return false;						var node:Node = new Node(elements[0]);						if (_first)			{				_last.next = node;				node.prev = _last;				_last = node;			}			else			{				_first = _last = node;			}						if (l > 1)			{				for (var i:int = 1; i < l; i++)				{					node = new Node(elements[i]);					_last.next = node;					node.prev = _last;					_last = node;				}			}						_size += l;			return true;		}						/**		 * Adds one or more specified elements to the beginning of the list.		 * 		 * @param elements The element(s) to prepend to the list.		 * @return true if the elements were prepended successfully.		 */		public function prepend(...elements):Boolean		{			var l:int = elements.length;			if (l < 1) return false;			var node:Node = new Node(elements[int(l - 1)]);						if (_first)			{				_first.prev = node;				node.next = _first;				_first = node;			}			else			{				_first = _last = node;			}						if (l > 1)			{				for (var i:int = l - 2; i >= 0; i--)				{					node = new Node(elements[i]);					_first.prev = node;					node.next = _first;					_first = node;				}			}						_size += l;			return true;		}						/**		 * Inserts the specified element into the list at the specified index. If the index		 * is 0 or smaller the element is prepended, if the index is equal or larger to the		 * list's size the element is appended. Any element that was on the specified index		 * is being pushed to the next index.		 * 		 * @param index The index at which to insert the element.		 * @param element The element to insert.		 * @return true if the element was inserted successfully.		 */		override public function insert(index:int, element:*):Boolean		{			if (index >= _size)			{				return append(element);			}			else if (index <= 0)			{				return prepend(element);			}			else			{				var node:Node = new Node(element);				var current:Node = _first;				var prev:Node;				var i:int = 0;								while (i < index)				{					prev = current;					current = current.next;					i++;				}								prev.next = node;				node.prev = prev;				node.next = current;				current.prev = node;								_size++;				return true;			}		}						/**		 * Replaces the element in the list at the specified index with the specified		 * element and returns the element that has been replaced or undefined if the list		 * is empty.		 * 		 * @param index The index at that the specified element should be placed.		 * @param element The replacing element.		 * @return the element that was orignially at the specified index or undefined if		 *         the list is empty.		 * @throws com.hexagonstar.exception.data.IndexOutOfBoundsException if the specified		 *             index is not in range, e.g. it is greater than the list's size or		 *             lower than 0.		 */		override public function replace(index:int, element:*):*		{			if (_size < 1)			{				return undefined;			}						if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else			{				var node:Node = new Node(element);				var current:Node = _first;								/* Replace first */				if (index == 0)				{					node.next = _first.next;					node.next.prev = node;					_first = node;				}				/* Replace last */				else if (index == _size - 1)				{					current = _last;					node.prev = _last.prev;					_last.prev.next = node;					_last = node;				}				/* Replace somewhere between first and last */				else				{					var prev:Node;					var i:int = 0;					while (i < index)					{						prev = current;						current = current.next;						i++;					}										prev.next = node;					node.prev = prev;					node.next = current.next;					node.next.prev = node;				}								return current.data;			}		}						/**		 * Removes the specified element from the list and returns it or undefined if the		 * element was not found in the List or if the list is empty.		 * 		 * @param element The element that should be removed from the list.		 * @return the removed element or undefined if the element was not found in the list		 *         or if the list is empty.		 */		override public function remove(element:*):*		{			if (_size < 1)			{				return undefined;			}						if (element === _first.data)			{				return removeFirst();			}			else if (element === _last.data)			{				return removeLast();			}						var node:Node = _first;			var i:int = 0;						while (i < _size - 2)			{				i++;				node = node.next;				if (node.data === element)				{					return removeAt(i);				}			}						return undefined;		}						/**		 * Removes the element at the specified index from the list and returns it or		 * undefined if the list is empty.		 * 		 * @param index The index from which the element should be removed.		 * @return the removed element or undefined if the list is empty.		 * @throws com.hexagonstar.exception.data.IndexOutOfBoundsException if the specified		 *             index is not in range, i.e. it is greater than the list's size or		 *             lower than 0.		 */		override public function removeAt(index:int):*		{			if (_size < 1)			{				return undefined;			}			if (index < 0 || index >= _size)			{				return throwIndexOutOfBoundsException(index);			}			else if (index == 0)			{				return removeFirst();			}			else if (index == _size - 1)			{				return removeLast();			}			else			{				var current:Node = _first;				var prev:Node;				var i:int = 0;								while (i < index)				{					prev = current;					current = current.next;					i++;				}								var node:Node = current;				prev.next = current.next;				current.next.prev = prev;				_size--;				return node.data;			}		}						/**		 * Removes the element that is at the beginning of the list and returns it or		 * undefined if the list is empty.		 * 		 * @return the removed element or undefined if the list is empty.		 */		public function removeFirst():*		{			if (_size < 1)			{				return undefined;			}						var node:Node = _first;			if (_first.next == null)			{				_first = _last = null;			}			else			{				_first.next.prev = null;				_first = _first.next;			}						_size--;			return node.data;		}						/**		 * Removes the element that is at the end of the list and returns it or undefined if		 * the list is empty.		 * 		 * @return the removed element or undefined if the list is empty.		 */		public function removeLast():*		{			if (_size < 1)			{				return undefined;			}						var node:Node = _last;			if (_first.next == null)			{				_first = null;			}			else			{				_last.prev.next = null;				_last = _last.prev;			}						_size--;			return node.data;		}						////////////////////////////////////////////////////////////////////////////////////////		// Bulk Operations                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Removes all of the elements from the list. The list will be empty after a call to		 * this method returns.		 */		public function clear():void		{			var node:Node = _first;			_first = null;						var next:Node;			while (node)			{				next = node.next;				node.next = node.prev = null;				node = next;			}			_size = 0;		}	}}// ---------------------------------------------------------------------------------------------/** * Node Class for DLinkedList * @private */internal class Node{	public var data:*;	public var next:Node;	public var prev:Node;		/**	 * Constructs a new Node instance for the DLinkedList.	 * @param d the content data for the Node object.	 */	public function Node(d:*)	{		data = d;		next = prev = null;	}}