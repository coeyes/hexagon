/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Copyright (c) 2007-2008 Sascha Balkau / Hexagon Star Softworks *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.display.bitmaps{	import com.hexagonstar.core.IDisposable;	import com.hexagonstar.display.IAnimatedDisplayObject;	import com.hexagonstar.event.FrameEvent;	import com.hexagonstar.time.FrameRateInterval;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	/**	 * Dispatched everytime a frame is entered.	 * @eventType com.hexagonstar.event.FrameEvent	 */	[Event(name="enterFrame", type="com.hexagonstar.event.FrameEvent")]			/**	 * Represents an animateable bitmap. When creating the AnimatedBitmap a bitmapData	 * object has to be specified that consists of horizonally layed out, same-sized	 * single frames that the AnimatedBitmap uses as frames for it's animation.	 * 	 * @author Sascha Balkau	 * @version 1.0.0	 */	public class AnimatedBitmap extends Bitmap implements IAnimatedDisplayObject,		IDisposable	{		////////////////////////////////////////////////////////////////////////////////////////		// Properties                                                                         //		////////////////////////////////////////////////////////////////////////////////////////				/** @private */		protected var _buffer:BitmapData;		/** @private */		protected var _interval:FrameRateInterval;		/** @private */		protected var _totalFrames:int;		/** @private */		protected var _currentFrame:int;		/** @private */		protected var _isPlaying:Boolean;		/** @private */		protected var _isDisposed:Boolean = false;		/** @private */		protected var _point:Point;		/** @private */		protected var _rect:Rectangle;		/** @private */		protected var _frameWidth:int;		/** @private */		protected var _resetWidth:int;						////////////////////////////////////////////////////////////////////////////////////////		// Public Methods                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Creates a new AnimatedBitmap instance.		 * 		 * @param bitmap The bitmapData object that contains the image sequence for the		 *            animated bitmap.		 * @param frameWidth The width of the AnimatedBitmap, this should be equal to the		 *            width of a single animation frame on the specified bitmapData.		 * @param interval The framerate interval used for the animated bitmap.		 */		public function AnimatedBitmap(bitmap:BitmapData,										   frameWidth:int,										   interval:FrameRateInterval,										   transparent:Boolean = true,										   pixelSnapping:String = "auto",										   smoothing:Boolean = false)		{			var h:int = bitmap.height;			super(new BitmapData(frameWidth, h, transparent, 0x00000000), pixelSnapping,				smoothing);						_buffer = bitmap.clone();			_totalFrames = _buffer.width / frameWidth;			_currentFrame = 1;			_isPlaying = false;			_interval = interval;			_point = new Point(0, 0);			_rect = new Rectangle(0, 0, frameWidth, h);			_frameWidth = frameWidth;			_resetWidth = -(_buffer.width - frameWidth);						bitmapData.copyPixels(_buffer, _rect, _point);		}						/**		 * Starts the playback of the animated bitmap. If the animated bitmap is already		 * playing while calling this method, it calls stop() and then play again instantly		 * to allow for framerate changes during playback.		 */		public function play():void		{	 		// TODO add reverse playback functionality.			if (!_isPlaying)			{				_isPlaying = true;				_interval.addEventListener(TimerEvent.TIMER, onInterval);				_interval.start();			}			else			{				stop();				play();			}		}						/**		 * Stops the playback of the animated bitmap.		 */		public function stop():void		{			if (_isPlaying)			{				_interval.stop();				_interval.removeEventListener(TimerEvent.TIMER, onInterval);				_isPlaying = false;			}		}						/**		 * Jumps to the specified frame nr. and plays the animated bitmap from that		 * position. Note that the frames of an animated bitmap start at 1 just like		 * a MovieClip.		 * 		 * @param frame an Integer that designates the frame from which to start play.		 * @param scene unused.		 */		public function gotoAndPlay(frame:Object, scene:String = null):void		{			_currentFrame = int(frame) - 1;			play();		}						/**		 * Jumps to the specified frame nr. and stops the animated bitmap at that position.		 * Note that the frames of an animated bitmap start at 1 just like a MovieClip.		 * 		 * @param frame an Integer that designates the frame to which to jump.		 * @param scene unused.		 */		public function gotoAndStop(frame:Object, scene:String = null):void		{			var f:int = int(frame);			if (f >= _currentFrame)			{				_currentFrame = f - 1;				nextFrame();			}			else			{				_currentFrame = f + 1;				prevFrame();			}		}						/**		 * Moves the animation to the next of the current frame. If the animated bitmap is		 * playing, the playback is stopped by this operation.		 */		public function nextFrame():void		{			if (_isPlaying) stop();			_currentFrame++;			if (_currentFrame > _totalFrames) _currentFrame = _totalFrames;			draw();		}						/**		 * Moves the animation to the previous of the current frame. If the animated bitmap		 * is playing, the playback is stopped by this operation.		 */		public function prevFrame():void		{			if (_isPlaying) stop();			_currentFrame--;			if (_currentFrame < 1) _currentFrame = 1;			draw();		}						/**		 * Disposes the animated bitmap.		 */		public function dispose():void		{			stop();			_isDisposed = true;		}				////////////////////////////////////////////////////////////////////////////////////////		// Getters & Setters                                                                  //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Sets the frame rate timer object used for the animated bitmap. This method is		 * useful when it is desired to change the framerate at a later timer.		 * 		 * @param timer The frame rate timer used for the animated bitmap.		 */		public function set frameRateInterval(v:FrameRateInterval):void		{			if (_isPlaying)			{				stop();				_interval = v;				play();			}			else			{				_interval = v;			}		}						/**		 * Returns the frame rate with that the animated bitmap is playing.		 * 		 * @return The fps value of the animated bitmap.		 */		public function get frameRate():int		{			return _interval.frameRate;		}						/**		 * Returns the current frame position of the animated bitmap.		 * 		 * @return The current frame position.		 */		public function get currentFrame():int		{			return _currentFrame;		}						/**		 * Returns the total amount of frames that the animated bitmap has.		 * 		 * @return The total frame amount.		 */		public function get totalFrames():int		{			return _totalFrames;		}						/**		 * Returns whether the animated bitmap is playing or not.		 * 		 * @return true if the animated bitmap is playing, else false.		 */		public function get isPlaying():Boolean		{			return _isPlaying;		}						/**		 * Determines if the object has been disposed (true), or is still available		 * for use (false).		*/		public function get isDisposed():Boolean		{			return _isDisposed;		}						////////////////////////////////////////////////////////////////////////////////////////		// Event Handlers                                                                     //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Plays the animation forward by one frame.		 * @private		 */		protected function onInterval(e:TimerEvent):void		{			_currentFrame++;			if (_currentFrame > _totalFrames)			{				_currentFrame = 1;			}			else if (_currentFrame < 1)			{				_currentFrame = _totalFrames;			}			draw();		}						////////////////////////////////////////////////////////////////////////////////////////		// Private Methods                                                                    //		////////////////////////////////////////////////////////////////////////////////////////				/**		 * Draws the next bitmap frame from the buffer to the visible area.		 * @private		 */		protected function draw():void		{			dispatchEvent(new FrameEvent(FrameEvent.ENTER_FRAME, _currentFrame));						_rect.offset(_currentFrame == 1 ? _resetWidth : _frameWidth, 0);			bitmapData.copyPixels(_buffer, _rect, _point);		}	}}